 Machine Translated by Google
********************************************
*ファミコンディスクシステムテクニカルリファレンス*
********************************************
ブラッド•テイラー (BTTDgroup@hotmail.com)
第3弾:2004年4月23日
NES コミュニティに感謝します。http://nesdev.parodius.com。
既存の関連ドキュメントを提供してくれた Nori と Goroh (およびそれぞれの翻訳を提供してくれた Ki と Sgt. Bowhack)、そしてずっと前に NESdev に投稿した予備的な ROM
BIOS ドキュメントを提供してくれた "D" という人物に特に感謝いたします。
推奨文献: FDS の統合電子サウンド シンセサイザーの動作に関する任天堂の特許文書 (US#4,783,812)。このデバイスはこの文 書では取り上げられていません。
注: このドキュメントを適切に表示するには、テキスト ビューアーに次の 2 つの機能が必要です: 1. 線描画文字を含 む従来の VGA ベースのテキスト
モード 256 文字セットのサポート。2. ワードラップ。Windows のメモ帳では、フォントをターミナル スタイルに変更すれ ば、これら 2 つ
の機能を簡単に実行できます。

+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|このドキュメントの内容|
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
‐序文
‐ RAMアダプタハードウェアに関する一般情報
‐ 2C33/LH2833 ピンの命名法と信号の説明
‐ RAMアダプタのディスク関連ハードウェア機能
‐ ROM BIOSの一般情報
‐ FDSディスクの起動に必要な手順
‐ 低レベルのディスクI/Oポートプログラミングの適切な手順
‐ ディスクシステムゲームがROM BIOSとどのように相互作用するか ‐ ROM BIOS ディスク I/O インターフェース ルーチンと構造
‐ ROM BIOS ディスク I/O ルーチン エミュレーションの考慮事項
‐ FDS ディスクドライブの動作の簡単な説明
‐ FDSデータ転送プロトコル
‐ FDS ディスク磁気エンコード形式
‐ 低レベルのディスクデータストレージレイアウト

 Machine Translated by Google
‐ FDS ディスク上のファイルの CRC 計算
‐ RAM アダプタのピン配置と機能
‐ ディスクドライブをエミュレートする手順 ‐ 通常は起動しないFDSディスクゲームを起動する
‐ コピープロテクションの回避
‐ ROM BIOSの分解

*********
*序文*
*********
ハードウェアの制限 (および 2 年という短い製品サイクル) を考慮しても、ファミコン ディスク システムが初めて動作を見たすべての 人に感銘を与え続ける
理由を理解するのはそれほど難しくありません。このシステムは、NES/FC を真のパーソナル コンピューティング プラットフォームに変 えたのです。
フロッピー ディスクを使用してシステムを起動し、お気に入りのゲームを起動する機能は、実際に自分の目で見てみなければ、その 真価はわかりません。
さらに、任天堂のゲームには進行状 況を保存する機能が搭載された最初のゲームである。
FDS形式で登場した。キッド•アイカルス、メトロイド、キャッスルヴァニアなどのゲームのFDSバージョンを見たことがないゲーマ ーにとって、これらのゲー
ムがすべてリリースされたという事実に非常に感銘を受けるのが普通である。
元々は FDS でセーブ機能があり、カート版のパスワード システムとは対照的でした (Castlevania を除く ‐ コナミはケチで、カ ート版の進行状況セーブのサポー
トを *すべて* 廃止しました。最後に、NES/FC ゲームの従来のサウンドは、FDS の追加のサウンド チャンネルを活用したゲームと比較 すると、ほとんど「粗 雑」であると言えます。サウンドを直接体験した人は、それがゲーム体験に本当に新しい次元を追加することに同意するでしょ う。結論: FDS

 Machine Translated by Google
クールでユニークなハードウェアです。
「FDS ローダー」プロジェクトは、インターネット上のあらゆる種類の FDS ゲームを自作のステレオ AV ファミコン コンソールでプレイし たいという私の願望から生まれまし
た。そこで、FDS 通信がどのように行われているのかを解明することにすぐに興味を持ちました。当時、英語で書かれた FDS 技術リフ ァレンス ドキュメントで、これが どのように実現されているかが説明されていることを知らなかったからです。最終的に、プロジェクトは完了し、すべ てがうまくいき、しばらくの間満足していました。しか
し、FDS RAM アダプターとハード ドライブ (または 3.5 インチ フロッピー ドライブ) 間の直接インターフェイスを設計し、PC の介入をすべて 廃止することを考え始めるま
ではそうでした。
一緒に。
これを実行する上で最大の問題は、
RAMアダプタは、12KB/秒という非 常に遅い速度でデータを転送するだけでなく、RAMアダプタの転送プロトコルは、一般的な転送プロトコルとはまったく互換性がありません。
フロッピーやハードドライブで見られるプロトコル(たとえば、標準の3.5インチフロッピーは4096ビットのブロック(セクター)で データを保存しますが、FDSデ
ィスクのデータストレージブロックの長さは動的です)。非互換性を回避するには、PC用に作成したプログラムと同様のプログラムを マイクロコントローラ用に作成する必要
があり、これがRAMとメモリ間のインターフェイスとして機能します。
アダプタ、ハードドライブ(または同様のもの)です。私は効率重視なので、より多くのメモリと
もっと 私が接続しているものよりも処理能力が高いというのはばかげた考えでした。

 Machine Translated by Google
そこで、ディスク通信にも RAM アダプターを使用する方法を考え始めました。
ほとんどのソフトウェア(ゲーム)は、 FDSはディスクアクセスを
自ら行わず、低レベルの処理をROM BIOSに依存しています。
ディスクアクセス。ゲームが行うことは、ROM BIOSがアクセスするためのファイル名(またはファイル数)を提供することだけです。 ゲームがこれをどのように行うかの
詳細は一般に知られていません。基本的に、私は
このインターフェースがあれば、ROM BIOSコードを書き直して、
ゲームがディスクアクセスを要求すると、私のルーチンは従来のBIOSと同じ方法で呼び出しを処理しますが、ディスク間のデータ転送 にFDSのディスクI/Oポ
ートを使用する代わりに、I/
NES/FC のメモリ マップに
マップされた IDE ハード ドライブの O ポート。
2002年の私の目標は、FDSのROM BIOSコードを研究し、ゲームがディスクサブルーチンにどうやってアクセスするのかを理解す ることでした。言うまでもなく、その目標は
達成され、ここに文書化されています。この追加(2004年)では、FDSディスクドライブ、ROM BIOSの技術的な操作に関する情報が提供さ れています。
分解、2C33 および LH2833 チップのピン配置の文書化、さらに FDS ディスクの修正手法、コピー保護の回避情報がすべてここに追加さ れ、これまでの FDS 関連
の研究結果がすべてこの 1 つのドキュメントに統合/結合されています。

*******************************
*RAMアダプタの簡単な情報*
*******************************

 Machine Translated by Google
RAM アダプタは、NES/ファミコン システム ハードウェアと FDS ディスク ドライブを接続するハードウェアです。RAM アダプタの内 部には、カスタム 32KB
DRAM チップ、パターン テーブル メモリ用の 8KB RAM チップ、FDS のオーディオ チャネルをシステム オーディオとミックスす るための回路、そして RAM アダ
プタの心臓部である 2C33 チップがあります。
DRAM チップ (部品番号: LH2833、シャープ製) ($6000..$DFFF にマッピングされています) には、2C33 チッ プ専用の接続が多数
あります。
いくつかのシステム アドレス ラインのみが DRAM に直接接続されているため、2C33 が DRAM のリフレ ッシュ サイクルとアドレ
ス指定を制御していることは明らかです。
DRAM のタイミングは謎ですが、バス クロック サイクルごとにランダムにアクセスできることは明らかで す。
BIOS ROM ($E000..$FFFF にマップされている) は、DRAM チップ (可能性は低い) または 2C33 チップ (可能性が高い) に統合され ています。ただし、その正確な位置
は不明です (いずれにしても、それほど重要ではありません)。
パターン テーブル メモリに使用される 8KB RAM チップは、PPU アドレス空間 $0000..$1FFF に完全にマ ップされます。2C33 は名前
テーブルのミラーリングを制御できますが、それ以外に RAM アダプタにはグラフィック制御に関連するハ ードウェアはありません。
RAM アダプタの心臓部である 2C33 には、ディスク I/O に関連するすべての回路と追加のサウンド チャネルが含まれています。

****************************************************
*2C33/LH2833 ピンの命名法と信号の説明*
****************************************************
___ ___

 Machine Translated by Google
|*\/|
/PRG >01]
A14 >02]
A13 >03]
A12 >04]
A11 >05] [60] (02) A10 >06] [59] (09) A9 >07] [58] (08) A8 >08] (22)
[09]
(23)[10] (24) [11]
(04)[12] (05)[13] (06)[14] (03)[15]
[64<VCC [63] クリスタル [62] クリスタル [61<VEE
[57< 読み取り/書き込み [56< φ2
[55> /IRQ
[54> AOUT [53<VEE
[52> SER OUT [51< SER IN [50> $4025W.2
[48> $4025W.0 [47< $4032R.2 [46< $4032R.1 [45< $4032R.0 [44] 内線0
[43] EXT1
[42] 内線2
[41] EXT3
[40] EXT4
[39] EXT5
[38] EXT6
[37] EXT7/バッテリー [36<CHR A10 [35<CHR A11
[34> VRAM A10 [33] D7
A7 >16]
A6 >17]
A5 >18]
A4 >19]
A3 >20]
A2 >21]
A1 >22]
A0 >23]
‐‐ [24]
D0 [25] D1
D2 D3 D4
D5 [30] D6 [31] VEE >32]
PHI2 >01] (60) [02] (15) [03] (12) [04] (13) [05] (14) [06]
A7 >07] [22] (09)
(58) [08] LH2833 [21< R/W
2C33 [49> $4025W.1
[26] [27] [28] [29]
|________|
___ ___
|*\/ |
[28<VCC [27<A13 [26<A14 [25< /PRG [24] (11) [23] (10)

 Machine Translated by Google
(59)[09]
‐‐ [10]
D5 [11]
D6 [12] D7
VEE >14]
[13]
[20<VEE [19] D4
[18] D3 [17] D2 [16] D1 [15] D0
|________|

/PRG: これは、PHI2 ラインでゲートされた NES/FC の A15 ライン NAND です。
A0‐A14、D0‐D7、R/W、PHI2、/IRQ: NES 6502 のアドレス、データ、制御、および割り込みライン (詳細については、「2A03 テクニカル リファレン
ス」ドキュメントを参照してください)。
XTAL: 2C33が21.48MHzの水晶をドロップするためのリード線。
機能。この周波数は、NTSC ベースの NES コンソールの 2A03 および 2C02 チップのクロック周波数とまったく同じであることに注意して ください。
VEE、VCC: それぞれグランド、+5VDC 電源信号。
EXT0‐EXT7: これらの双方向ピンは、アドレス $4026 および $4033 にマップされた内部レジスタの内容に関連します (詳細は後述)。
$4025Wx: 出力は内部ラッチから直接供給され、その位置にマッピングされる。 住所。
$4032Rx: アクセス時にこのポートが返す値に影響する入力。
SER IN、SER OUT: シリアル入力および出力信号 (FDS ディスク データ信号)。
CHR A10‐A11、VRAM A10: PPUミラーリング制御。
AOUT: 2C33 の内部サウンドシンセサイザーのアナログ出力。

 Machine Translated by Google
(): 括弧内の数字は、2C33 チップと LH2833 チップ間のプライベート ピン接続を示します。文書化されていませんが、これらの信号 は LH2833 の DRAM タ
イミングを維持する役割を果たします。
‐‐: 未使用/未接続。

***********************************
*2C33 のディスク関連ハードウェア*
***********************************
2C33 のディスク ハードウェアは、データ入出力ワイヤに表示されるシリアル データを処理および送信するためだけに存在し ます。その他のすべての制
御信号は、FDS ポートにプログラムされているバイナリ値を直接反映します (逆も同様)。
2C33 の内部には、RAW シリアル データを磁気ディスクにバイナリ データを格納するために使用されるプロトコルに変換する (またはその 逆) ための電子機器が
いくつか使用されています。この点に注意してください。後述のポートの説明では、ディスク データ入力/出力が内部シフト レ ジスタに直接接続されていることが示さ
れています。ただし、これは単に説明を簡略化するためです。実際には、ディスク データは RAM アダプタに出入りする前に処理さ
れます。
さらに、ディスクから読み取られた生
のシリアル データには、2C33 がシフト レジスタの一部をクロックするために使用するクロック レートも含まれます。
2C33 内部のディスク関連ハードウェアには以下が含まれます。
‐ 8 ビット シリアル出力/パラレル入力シフト レジスタ (SR) (データをシリアル化してディスクに保存するため)
‐ 8 ビット シリアル入力/パラレル出力 SR (ディスクからのシリアル データを組み立てるため) ‐ 16ビット巡回冗長検査(CRC)SR(ポリ=10001000000100001b(X25

 Machine Translated by Google
標準))
‐ 4 ビット SR はジョンソン カウンターとして使用されます (このカウンターはビット数を追跡します)
注: この文書では、2C33 の内部アーキテクチャについてこれ以上詳しく説明しません (2C33 の実際の設計図がないため)。2C33 には、 私が知らない他の
ハードウェア (追加のシフトレジスタなど) が存在する可能性があります。このアーキテクチャ情報は、プログラマーに内 部で何が起こっているかを伝えるため
にのみ提供されています。
2C33.
ディスクポート ‐‐‐‐‐‐‐‐‐‐
‐ ポート$402xは書き込み専用です ‐ ポート$403xは読み取り専用です
ここではディスク関連のポートのみを記載しています。
その他の FDS ポート (サウンド、タイマーなど) に関する情報については、FDS 関連のドキュメントを参照してください。
+‐‐‐‐‐+
|$4024| +‐‐‐‐‐+
データレジスタを書き込みます。
このレジスタにプログラムされるデータは、シフト レジスタにロードされる次の 8 ビット量 (次にバイト転送フラグが上がったとき) となり、シフト アウト
されて RAM アダプタ ケーブルのピン 5 (2C33 ピン 52) に表示されます。
+‐‐‐‐‐+

 Machine Translated by Google
|$4025| +‐‐‐‐‐+
FDS制御。
ビットの説明 ‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
0: RAM アダプタ ケーブルのピン C (2C33 ピン 48) に電気的に接続されています。アクティブ (0) の場合、ディスク ドライブ モーター が停止します。この間、$4025.1 は効果があり
ません。
1: RAMアダプタケーブルのピン3(2C33ピン49)に電気的に接続されています。アクティブ(0)の場合、ディスクドライブモーターがオン になります。このビットはディスク転送中はア
クティブである必要があります。そうでない場合、$4032.1は常に1を返します。
非アクティブの場合、ディスク ドライブ モーターは、ディスク ヘッドがディスクの最も内側のトラックに到達す るまでオンのままになります。
2: RAM アダプタ ケーブルのピン 1 (2C33 ピン 50) に電気的に接続されます。
ディスク データの転送方向を制御します。ディスク データを読み込む場合は 1 に設定し、書き込む場合は 0 に設定しま す。
3: ミラーリング制御。0 = 水平、1 = 垂直。
4: CRC 制御。ROM BIOS サブルーチンは、ブロックの末尾の CRC データを処理中にこのビットを設定します。ブロック読み取り中にこの
ビットが設定される理由は不明ですが、ブ
ロック書き込み中にこのビットが設定されると、2C33 に CRC レジスタの現在の内容をディスクにパイプするように指示します (この間、$4024 の データは実質的に無視されま
す)。
5: 常に1に設定(不明を使用)
6: このビットは通常、ディスクヘッドがGAP期間にあるときに設定されます。

 Machine Translated by Google
ディスク。これが完了すると、2C33の内部CRCにリセットが発行されます。 アキュムレータ。
読み取り中に、このビットを設定すると、2C33 は、FDS の内部シフト レジスタにシリアル データを蓄積する前に、ディスクから読み取られる 最初の設定ビット (ブロック
開始マーク) を待機し、バイト転送準備完了フラグを初めて設定します (その後、8 ビットごとの後続の転送ごとに設定)。
書き込み中にこのビットを設定すると、2C33 は $4024 の内容を直ちにシフト レジスタにロードし、バイト転送フラグを設 定し、シフト レジスタからディスクへのデー
タの書き込みを開始し、後続の 8 ビット転送でこのプロセスを繰り返すように指示されます。このビットが 0 の間、$4024 のデータは無視され、代わりに 0 のストリーム
がディスクに書き込まれます。
7: 設定されている場合、バイト転送フラグが上がったときに IRQ を生成します。
+‐‐‐‐‐‐‐‐‐‐‐+
|$4026/$4033| +‐‐‐‐‐‐‐‐‐‐‐+
それぞれ外部コネクタ出力/入力。$4026 の出力 (4.7K オームのプルアップ付きオープン コレクタ (ビット 7 を除く)) は、$4033 の入力と共 有されま
す。
ビット 2C33 拡張接続 ‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐
0 443 1 434 2 425 3 416 4 407 5 398

 Machine Translated by Google
6 389 7 37‐
ここでのビット 7 は、ドライブの電源状態 (1 = 電源良好) を報告するために使用されます。これは、RAM アダプタ ケーブルのピン 6 に電 気的に接続されています。$4033
を介してバッテリの状態を確認する前に、$4026 ビット 7 を 1 に設定する必要があります (そうでない場合、常に 0 が返されます)。
+‐‐‐‐‐+
|$4030| +‐‐‐‐‐+
2C33 ステータス。
ビットの説明 ‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
0: IRQ タイマー レジスタに関連します (ここでは説明しません)。 1: バイト転送フラグ。8ビットが転送されるたびにセットされます。
RAM アダプタとディスク ドライブ (サービス $4024/$4031)。$4024、$4031、または $4030 がサービスされた らリセットします。
4: CRC レジスタに 0 が含まれている場合はクリアします (転送が CRC に合格したことを示します)。
6: 不明な操作。おそらく $4032.1 に関係します。
7: 不明な操作。おそらく $4023.0 に関連しています。
+‐‐‐‐‐+
|$4031| +‐‐‐‐‐+
データレジスタを読み取ります。 このレジスタには、バイト転送フラグが立つたびに内部シフトレジスタの内容がロードされます。シフトレジスタは、

 Machine Translated by Google
RAM アダプタ ケーブルのピン 9 (2C33 ピン 51) 経由のシリアル データ。
+‐‐‐‐‐+
|$4032| +‐‐‐‐‐+
ディスク ドライブのステータス。
ビットの説明 ‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
0: RAM アダプタ ケーブルのピン A (2C33 ピン 45) に電気的に接続されています。アクティブ (0) の場合、ドラ イブにディスクが挿入されているこ
とを示します。
1: RAM アダプタ ケーブル (2C33 ピン 46) のピン B に電気的に接続されています。この信号の負の遷移 (‐_) では、ドライブ ヘッ ドが現在最も外側のトラック (ディス
クの先頭) にあることを示します。
このビットは、ディスク ドラ
イブ ヘッドが最も内側のトラック (ディスクの終わり) に進むまで、または $4025.1 がいつでも 1 である場合は 0 のままになります。
2: RAM アダプタ ケーブルのピン 7 (2C33 ピン 47) に電気的に接続されています。アクティブ (0) の場合、ディ スクが挿入され、書き込み可能であ
ることを示します (読み取り専用ではありません)。
6: 1を返すとみなされる
***********
*ROM BIOS* ***********
FDS がオンになっているとき、目に見えるものや聞こえるもの (点滅する Nintendo ロゴ、走り回るマリオとルイージなど) は、ROM BIOS コード から実行されます。
ROM BIOSコードは8Kバイトのサイズで、CPUメモリマップの$E000..$FFFFに格納されています。BIOS内には数十のサ ブルーチンがありますが、

 Machine Translated by Google
このドキュメントでは、ディスク インターフェイス サブルーチン (後述) に焦点を当てます。
BIOSデータ領域 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐
BIOS はメモリ内のいくつかの場所を使用しますが、ゲーム コードによって維持されることが想定されるのはそのうちの一部のみで す。それらは次のとおりで
す([]=8ビット、()=16ビット)。
($DFFE): ディスクゲームIRQベクター ([$0101] = 11xxxxxxBの場合) ($DFFC): ディスクゲームリセットベクトル (($0102) = $5335の場合、または
$AC35)
($DFFA): ディスク ゲーム NMI ベクトル #3 ([$0100] = 11xxxxxxB の場合) ($DFF8): ディスクゲーム NMI ベクター #2 ([$0100] = 10xxxxxxB の場合) ($DFF6): ディスクゲーム NMI ベクトル #1 ([$0100] = 01xxxxxxB の場合)
($0102): リセット時のPCアクション
[$0101]: IRQ での PC アクション。リセット時に $80 に設定されます [$0100]: NMI時のPCアクション。リセット時に$C0に設定される
[$FF]: リセット時に [$2000] $80 に最後に書き込まれた値。
[$FE]: リセット時に [$2001] $06 に最後に書き込まれた値
[$FD]: 最後に書き込まれた値は [$2005]#1 リセット時に 0 になります。 [$FC]: [$2005]#2 に最後に書き込まれた値はリセット時に 0 になります。 [$FB]: [$4016] に最後に書き込まれた値はリセット時に 0 になります。 [$FA]: リセット時に [$4025] $2E に最後に書き込まれた値。
[$F9]: リセット時に[$4026] $FFに最後に書き込まれた値。
$F9..$FF のメモリは、前述のポートと常に同期されています。これは、これらのポートが書き込み専用であるためです。
その結果、これらのポートにプログラムさ れている現在の値は、常にここで読み取ることができます。
ゼロ ページには、さらに構造化されたデータ領域が存在する場合があります (たとえば、BIOS ジョイパッド ルーチンは、コントロー ラーの読み取りを格納す
るために $F5..$F8 を使用します) が、ディスク呼び出しサブルーチンによって使用されるのは、リストされているデータ 領域のみです。

 Machine Translated by Google
ディスクゲームの起動 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
ディスクのブート ファイルがメモリに正常にロードされると (詳細は後述)、($0102) に $AC35 が割り当てられ、BIOS データ 領域 (およびそれぞれのポート)
が前述のリセット値に設定されます。
最後に、割り込みが
有効になり、プログラム制御が ($DFFC) ベクトルに転送されます。
**************************************
*ROM BIOSディスク手順情報* **************************************
ディスク関連の BIOS コードはほぼすべて [$E1C7..$E7BA] の範囲内に存在するため、ROM BIOS の逆アセンブリを見るときはこの 点に留意し
てください。
‐ ROM BIOS には、ディスク ルーチンとディスク サブルーチンがあります。ルーチンはソフトウェアへのインターフェイスを提 供する手順であり、サブルーチン
はルーチンにディスク ハードウェアへのインターフェイスを提供します。
この文書の後半では、すべ ての既知のディスクルーチンと重要なディスクサブルーチンについて説明します。
文書化されています。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ディスクサブルーチンデータ領域| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
すべての ROM BIOS ディスク サブルーチンは、少量のゼロ ページ メモリを使用します。ディスク ルーチンは通常、このメモリ領 域を介してサブルーチン
にパラメータを渡します。
ディスクルーチンはサブルーチンを呼び出す前にこの領域にあるデータを保存しないので、ディスクルーチンを呼び出 すプロシージャは、呼び出し中にこ の領域に重要なデータを保持しないようにする必要があります。次のリストで説明します。

 Machine Translated by Google
サブルーチンが使用するゼロページメモリとその共通使用法([] = 8ビット、() = 16ビット)。
($00) 最初のハードコードされたパラメータ ($02) 2番目のハードコードされたパラメータ
[$04] 前のスタックフレーム
[$05] エラー再試行回数
ファイルカウンター [$07] 現在のブロックタイプ
[$06]
ブートIDコード
[$09] ダミー読み取りを行うには0以外
[$08]
宛先住所 ($0C) バイト転送数
($0A)
[$0E]
ファイル発見カウンタ
このメモリの他に、ディスクサブルーチンでは、 ROM BIOSデータ
領域($F9..$FF)は適切に維持されます。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|一般的なディスク エラー| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
ディスク I/O 操作が (何らかの理由で) 失敗すると、失敗の性質を反映したエラー番号が生成されます。使用される一般的なエラー 番号は次のとおりです (特
殊なエラー番号については後で説明します)。
00: ディスクI/Oが成功しました(エラーなし)
01: ($4032.0) ディスクが設定されていません
02: ($4033.7) 電源障害(バッテリーなど)
03: ($4032.2) ディスクは書き込み禁止です
21: ブロック1の「*NINTENDO‐HVC*」文字列が一致しません
22: ブロックタイプ1が期待される
23: ブロックタイプ2が期待される
24: ブロックタイプ3が期待される
25: ブロックタイプ4が期待される
27: ($4030.4) ブロックの CRC が失敗しました
28: ($4030.6) ファイルが読み取り中に途中で終了しました
29: ($4030.6) 書き込み中にファイルが途中で終了しました
30: ($4032.1) ディスク ヘッドが最も内側のトラックに到達しました (終了)

 Machine Translated by Google
***************************
*ROM BIOS ディスク サブルーチン* ***************************
以下は、最も重要な ROM BIOS ディスク サブルーチン (NES/FC メモリ マップのエントリ ポイント アドレスを含む) の一部に関するドキュメントです。この情報は主に、
ディスク I/O 転送中に ROM BIOS が従う正確な手順を示すために提供されています。これは、高レベルのディスク インターフェイス
手順 (後述) の方が、ディスク データに アクセスするはるかに簡単で実用的な方法だからです。
ほぼすべての手順で発生する低レベル イベントの擬似コード リストが提供されています。擬似コードは、ROM BIOS コードが実行する I/O イベントを *正確に* 再現します
(一部の書き込みは不要に見えますが)。エミュレータ作成者と FDS 低レベル コード
開発者にとって、この情報は特に役立つはずです。疑似コードでは、「x」は重要でないビット (比較中) または変更 されないビット
(割り当て中) を表すために使用されます。
+‐‐‐‐‐+
|遅延| +‐‐‐‐‐+
エントリーポイント: $E153
Yオンコール:
説明: 時間遅延ジェネレーター。
+‐‐‐‐‐‐‐‐+
|バイト転送| +‐‐‐‐‐‐‐‐+
エントリーポイント: $E7A3
オンコール:
遅延(ミリ秒)
ディスクに書き込むバイト数

 Machine Translated by Google
戻り値: ディスクからバイト読み取り
説明: IRQ が発生するのを待ってから、[$4031] を読み取り、[$4024] を書き込みます。
書き込みフラグ ($4025.2) の現在のステータスによってのみ、データが実際にディスクに書き込まれるか、または有効 なデータがディスクから読み取られるかが決ま
ります。
論理:
(IRQ発生を待つ)
温度=[$4031] [$4024]=A
A=温度 戻る
+‐‐‐‐‐+
|エラー| +‐‐‐‐‐+
エントリーポイント: $E781 X オンコール: エラーコード
エラーコード スタックを以前の状態に復元し、データ転送を終了します。
戻り時の A、X: 説明: 戻る前に
論理:
戻る
+‐‐‐‐‐‐‐‐‐‐+
|待機待ち| +‐‐‐‐‐‐‐‐‐‐+
スタックフレームを以前の状態に復元する スキャンディスクビットを無効にする
S = [$04]; 状態
[$4025] = 0010x11x; A=X=エラーコード
エントリーポイント: $E64D
説明: データ転送用にディスク ドライブを初期化するために使用されます。
論理:
[$4025] = 0010x110; 実行中)
遅延(512)
[$4025] = 0010x111; [$4025] = 0010x101;
モーターを停止します(すでに停止している場合)
無効 ディスクをスキャン

 Machine Translated by Google
遅延(150); オン モーターが
[$4026] = 1xxxxxxx; バッテリーチェックを有効にする
if ([$4033] = 0xxxxxxx);バッテリーの正常ビットをチェック
エラー($02)
[$4025] = 0010x110; [$4025] = 0010x111; [$4025] = 0010x101; 繰り 返し
([$4032] = xxxxxxx1) の場合 エラー($01);ディスクセットを常に検査する
until ([$4032] = xxxxxx0x);準備完了フラグが 活性化
戻る
+‐‐‐‐‐‐‐‐‐‐‐‐+
|ブロックタイプのチェック| +‐‐‐‐‐‐‐‐‐‐‐‐+
再びモーターを停止する 無効
ディスクを再度スキャンする
エントリーポイント: $E68F
オンコール: 予想されるブロックタイプ
説明: 新しいデータ ブロックの最初のバイトを A で渡されたバイトと比較します。テストが失敗した場合はエラーを生成しま す。
論理:
現れる
+‐‐‐‐‐‐‐‐‐‐‐‐+
|書き込みブロックタイプ| +‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E6B0 オンコール: 作成するブロックタイプ
GAP期間に5ms進む ブロック開始マークを待つ
遅延(5); [$4025] = x1xxxxxx;
[$0101] = 01000000; [$4025] = 1xxxxxxx; if (XferByte <> BlockType);
ブロックの最初のバイトをテスト
エラー($21+ブロックタイプ) 戻る
IRQモードをディスクバイト転送に設定する ディスク転送IRQを有効にする
説明: 新しいデータ ブロックを作成し、渡されたブロック タイプを最初のバイトとして書き込みます。
論理:
[$4025] = 00x0x0xx;
転送方向を書き込みに設定する

 Machine Translated by Google
遅延(10); [$4024] 10msのギャップ期間を作成する
= 00000000; 書き込みデータレジスタをゼロにする
[$4025] = 01x0x0xx; $4024経由でデータの書き込みを開始 ディスク
[$0101] = 01000000; [$4025] = IRQモードをディスクバイト転送に設定する 1xxxxxxx; ディスク転送IRQを有効にする
XferByte($80);
ブロック開始マークを書き出す
XferByte(BlockType); 指定されたブロックタイプを書き出す 戻る
+‐‐‐‐‐‐‐‐‐‐‐‐+
|ブロック読み取り終了| +‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E706
説明: ブロックからすべてのデータ(それ以上でもそれ以下でもない)が取得されたときに呼び出されます
読み込まれました。CRC ビットをテストしてデータ ブロックの整合性を確認します。 論理:
XferByte; CRCバイト1のダミー読み取り ([$4030] = x1xxxxxx) の場合
エラー($28)
[$4025] = xxx1xxxx; CRCバイト2のダ プロセスCRCビットをアクティブ化
XferByte; if ([$4030] ミー読み取り
= xxx1xxxx);テスト (CRC アキュムレータ = ゼロ) ステータス
エラー($27)
[$4025] = 00x0x1xx; さらなるディスク IRQ などを無効にします。
if ([$4032] = xxxxxxx1);ディスクセットの状態を確認する
エラー($01) 戻る
+‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ブロック書き込み終了| +‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E729
説明: すべてのデータがブロックに書き込まれたときに呼び出されます。FDS ハードウェアによって生成された 16 ビッ トの CRC 値をファイルの最後の 2
バイトとして書き出します。
論理:
XferByte; レジス 最後のバイトをシフトに書き込む
タ
([$4030] = x1xxxxxx) の場合

 Machine Translated by Google
エラー($29)
[$4025] = xxx1xxxx; 遅延(0.5)用に書き込 プロセスCRCビットをアクティブ化
まれたCRCレジスタの内容; 0.5 ms
if ([$4032] = xxxxxx1x);ドライブの準備状態を確認する エラー($30)。ディスク ヘッドがディスクの終わりに到達しました。
[$4025] = 00x0x1xx; さらなるディスク IRQ などを無効にします。 if ([$4032] = xxxxxxx1);ディスクセットの状態を確認する
エラー($01) 戻る
ディスクブロック処理の例 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
(ディスク上の最初のブロックを読み取り中)
待機待ち; ドライブを初期化し、準備完了フラグを待つ 遅延(267); 最初のGAP期間に267ミリ秒進む
CheckBlkType(); ブロックタ イプを確認する
ブロック開始マークを待つ &
(ディスクからデータを読み取ることができる場所) ブロック読み取り終了
(ディスク上の最初のブロックの書き込み *) 待機待ち
[$4025] = 00x0x0xx; 転送方向を書き込みに設定
遅延(398); 398 msのGAP期間を作成する
WriteBlkType(); 10ms以上のギャップの後、ブロックタイプを書き込みます
(データをディスクに書き込むことができる場所) ブロック書き込み終了
(ディスク上の後続のブロックの読み取り) チェックブロックタイプ()
(ディスクからデータを読み取ることができる場所) ブロック読み取り終了
(後続のブロックをディスクに書き込む) 書き込みブロックタイプ()
(データをディスクに書き込むことができる場所) ブロック書き込み終了
(エラーが発生した場合も含め、ディスク転送を終了します)
エラー(); 成功
ディスク転送時にエラー番号が0に設定される

 Machine Translated by Google
*: ROM BIOSコードでは、これを行うための標準的な方法は提供されていません。FDSディスクの最初のデータブロッ
クを書き換える必要があるゲーム では、
フォロー
ここで例を示します。記載されている遅延値は、ディスクの最初の GAP 期間のサイズの近似値です。この数値 は、一般的な FDS ディスクの GAP 期間のサイズに基づ
いています (1.5x という数値に従うようです。ここで、x は ROM BIOS が最初のブロックの読み取り中にギャップ期間で待機する時間 です)。
************************
*ROM BIOS ディスク ルーチン* ************************
これらは、FDS ゲームがディスク アクセスに使用するルーチンです (おそらく唯一のルーチンです)。これらは、JSR $xxxx 命令を介 して FDS ゲーム コードから直接
呼び出されます。ルーチンが機能するパラメーターは、JSR $xxxx 命令に続く命令ストリームにハードコードされています。
各パラメータは16ビットで、 1つまたは2つ存在する可能性があります。呼び出されたサブルーチンは常にスタックを固定し、プログラム制 御がサブルーチンの終了後に命令に戻るよう
にします。
ハードコードされたパラメータ。
‐ これらのルーチンの 1 つが呼び出されると、ディスク転送を開始する前に、ディスク セット ステータス ($4032.0) と、ディスクに書き 込むルーチンの場合は書き込
み保護ステータス ($4032.2) がチェックされます。これらのテストが失敗すると、最終エラー # が生成されます。ディスク転送中に エラーが発生した場合、エラ
ーが最終エラーとみなされる前に、転送の 2 回目の試行が行われます。

 Machine Translated by Google
‐ 最終的なエラーが発生した後、プログラム制御は
呼び出しに続く命令では、エラー コードは A と X に含まれ、符号とゼロ フラグはエラー番号を反映するように設定されます。
‐ ディスク呼び出しがすぐに返ってくるとは思わないでください。数秒かかる場合があります。
完了。
‐ ROM BIOS は、ディスク間でデータを転送するために常にディスク IRQ を使用するため、プログラムはこれらのディスク 呼び出し中に IRQ 制御を ROM BIOS に引き
渡す必要があります。
ただし、[$0101] の値は入口で保存され、出口で復元されます。
パラメータと手順 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
まず、ディスク ルーチンが操作する構造の種類について説明し、次にディスク ルーチン自体について説明します。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ディスク識別ヘッダー文字列 (DiskID)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
これはよく使われる文字列です。10バイトで構成され、
バイト15..24('*NINTENDO‐HVC*'の直後)と直接比較します。
ディスクのヘッダーブロック(ブロックタイプ1、常にディスク上の最初のブロック)のバイト列を比較します。いずれかのバイト が比較に失敗した場合、
適切なエラー#が生成されます。重要でないデータの比較は、ディスクID文字列の適切な場所に$FFバイトを配置する ことでスキップできます(たとえば、
ROM BIOSがディスクを起動すると、ディスクID文字列のすべてのフィールドが‐1に設定されますが、ディスクサイド#とディス ク#は0に設定されます(し
たがって、これらのフィールドには

 Machine Translated by Google
0 と一致する)。次の表は、DiskID 構造と、比較が失敗したときに返されるエラー番号を示しています。
オフセットサイズエラー#説明 ‐‐‐‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
01 14 51 61 71 81 91
あ
$04 ゲームメーカーコード $05 ゲーム ASCII 名文字列 $06ゲームバージョン
$07 ディスク面 # $08ディスク# 追加ディスク # データ $09 追加ディスク # データ $10
‐
|ファイルロードリスト (LoadList)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
この文字列は、ゲームでディスクからメモリにロードするファイルを指定する必要がある場合に使用されます。 LoadList の各バイトは、メモ リにロードするファイルを指定し
ます。 ファイル ヘッダーがディスクから順番に読み取られると、ファイル識別コード (FileID、ブロック タイプ 3 のバイト オフセット 2) が LoadList のすべての要素と
比較されます。 一致が見つかった場合、ファイルがロードされます。
これは、ディスク上にファイルがなくな るまで(保存されているファイル数で示される)実行されます。
LoadList は $FF エントリで終了できます。リストの最初の 20 エントリのみが処理されます (これは、この間に比較アルゴリズムに使用で きるクロック サイク
ルが約 800 サイクルしかないためです)。$FF が文字列の最初の要素である場合、これはブート ロード ファイル コード (BootID、ディスクのブロック 1、バイト オフセット
25 に格納) を使用して、ディスクからロードするファイルを決定することを示します。
(この場合、ファイルをロードするための条件は (BootID >= FileID) です)。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+

 Machine Translated by Google
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ファイル ヘッダー (FileHeader)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
この構造体は、ファイルをディスクに書き込むときに指定されます。この構造体の最初の14バイトは、書き込みに使用するデータを直 接指定します。
ディスクに書き込むファイルヘッダーブロック(タイプ3、バイト[2..15])を生成します。最後の2つのエントリは、ディスクに書き 込まれるファイルデータに関するもので
す。
(ブロックタイプ4)。
以下は、FileHeader 構造を説明する表です。
オフセットサイズの説明 ‐‐‐‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
00 01 09 0B
0D 0E 10
11
1 ファイルIDコード
8 ファイル名
2 ロードアドレス
2 ファイルデータサイズ
1 ロード領域 (0 = CPU データ、その他 = PPU)
2 ファイルデータのソースアドレス(ディスクに書き込まれていない)
1 ソースアドレスタイプ (0=CPU、その他=PPU; ディスクに書き込まれない)
‐
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ディスク情報 (DiskInfo)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
これは、サブルーチンによって返される、ディスクから収集された情報 (ディスク上のファイルのリスト、ディスク サイズな ど) のデータ構造です。次の表は、その構造の説
明です。
オフセットサイズ ‐‐‐‐‐‐ ‐‐‐‐
01
14
51
6 1 ディスク面 #
7 ディスク1枚#
8 追加ディスク1台#データ
ゲームメーカーコード ゲームASCII名文字列 ゲームバージョン

 Machine Translated by Google
9 追加ディスク1台#データ ディスク上のファイル数 1
(次のブロックは、「ディスク上のファイル数」バイトが示す数のファイルに対して表示されます)
B 1 ファイル ID コード
C
8 ファイル名 (ASCII)
(最後のファイル情報ブロックの後に次の内容が存在します。 ディスク サイズは、各ファイルのサイ
ズ エントリの合計に、ファイルごとに 261 を加えたサイズになります。
1 ディスクサイズ上位バイト x+1 1 ディスクサイズ下位バイト
バツ
x+2
+‐‐‐‐‐‐‐‐‐‐+
|ファイルの読み込み| +‐‐‐‐‐‐‐‐‐‐+
エントリポイント: $E1F8 RETaddr: DiskIDへのポインタ
RETaddr+2: 戻り値: エラーコード
LoadListへのポインタ
‐
戻り値 Y: 実際に見つかったファイルの数
説明: DiskID で指定されたファイルをディスクからメモリに読み込みます。読み込みアドレスはファイルのヘッダーによ って決定されます。
+‐‐‐‐‐‐‐‐‐‐‐+
|ファイルを追加| +‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E237 RETaddr: DiskIDへのポインタ
RETaddr+2: 戻り値: エラーコード
FileHeaderへのポインタ
特別なエラー: 検証段階が失敗した場合は #$26
説明: DiskIDで指定されたファイルデータをディスクに追加します。つまり、ファイルはディスクの末尾に追加され、ディス クファイル数は

 Machine Translated by Google
増分されます。その後、書き込みを確認するためにファイルが読み戻されます。 エラーが発生した場合
検証中に発生すると、ディスクのファイル数が減算されます (書き込まれたファイルは論理的に隠されます)。
+‐‐‐‐‐‐‐‐‐‐+
|ファイルを書き込む| +‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E239 RETaddr: DiskIDへのポインタ
RETaddr+2: 書き込
オンコール:
戻り値: エラーコード
特別なエラー: 検証に失敗した場合は #$26
説明: 「ファイルの追加」と同じですが、ファイルをディスクの末尾に書き込む代わりに、A はファイルを書き込むディスク上の連続位置 を指定します (0 が最初)。これによ
り、ディスクのファイル数が A 値に設定される効果もあり、書き込まれたファイルの後に存在する可能性のある他のファイルが論理的に 非表示になります。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ディスク情報を取得| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E32A
RETaddr: DiskInfoへのポインタ 戻り値: エラーコード
説明: 現在のディスクから読み取ったデータで DiskInfo を埋めます。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ファイル数を調整| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E2BB RETaddr: DiskIDへのポインタ
オンコール:
戻り値: エラーコード
現在のファイル数を減らす数
FileHeaderへのポインタ
むファイルのファイルシーケンス番号

 Machine Translated by Google
特別なエラー: count #Aがディスクのファイルより小さい場合は$31
説明: ディスクのファイル数を読み取り、それをAだけ減らし、次に書き込みます。 新しい値が戻ります。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ファイル数を確認| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリポイント: $E2B7
RETaddr: DiskIDへのポインタ
オンコール: ファイル数を設定する数値
戻り値: エラーコード
特別なエラー: count #Aがディスクのファイルより小さい場合は$31
説明: ディスクのファイル数を読み取り、それをAと比較し、 ディスクのファイル数を A にします。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ファイル数の設定 (alt. 1)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E305
RETaddr: DiskIDへのポインタ
オンコール: ファイル数を設定する数値
戻り値: エラーコード
説明: ディスクのファイル数を A に設定します。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|ファイル数の設定 (alt. 2)| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
エントリーポイント: $E301
RETaddr: DiskIDへのポインタ
オンコール: ファイル数をマイナス1に設定する数値
戻り値: エラーコード
説明: ディスクのファイル数を A+1 に設定します。
************************************************
*ROM BIOS ディスク ルーチン エミュレーションの考慮事項* ************************************************

 Machine Translated by Google
野心的なNES/FCエミュレーターの作者は、内蔵のFDSディスクルーチンインターフェースを装備し(そしてディスク関連のROM BIOSコ ードをすべて廃止)、FDSで書かれた
ゲームをNESエミュレーター上でカートリッジ/ROMベースのゲームと同じくらい速く実行することができます。これは、あなたが思 いつく限りのFDSゲームをプレイしてい
るときに、セーブ/ロード画面を1つも目にすることはないだろうことを意味します。
定期的なサイド変更プロンプト。
NES 6502 エミュレーション アドレス デコードをフルサイズの 17 ビット アドレス ルックアップ テーブルに基づいて行うエミュレー
タの場合、FDS ルーチンへのア
クセスをトラップするのは簡単です。他のエミュレータでは、ROM BIOS のディスク ルーチンのターゲット アドレスで 6502 ジャム オペコ ードを使用して、6502 エンジンに、
FDS ディスク要求を処理する別のエミュレータ ルーチンに制御を渡すように指示する必要があります。
これらのルーチンへのアクセスがトラップされると、ディスク データにアクセスするために仮想 2C33 エンジンを使用する必要がないこと を除いて、ROM BIOS コードと同じタ
スクを実行するハンドラーを記述します。また、CPU サイクル カウント情報は無関係なので、心配する必要はありません。FDS ディスク デ ータはエミュレータのヒープのど
こかにキャッシュされている可能性が高いため、ディスク ルーチンが行う作業のほとんどは、FDS ディスク キャッシュ メモリから NES のメ モリ マップに数千バイトをコピー
することから構成されます。
ディスクルーチンをエミュレートするもう1つの利点は、ゲームによってディスクアクセスが要求されたときに、適切なサイドとディスク番号が 呼び出しとともに指
定されることです。これらのパラメータを調べることができ、一致するFDSディスクイメージを見つけることができます。

 Machine Translated by Google
ユーザーにどちらの面(またはゲームディスク)を選択するか尋ねることなく、選択することができます。ユーザーが対処しなければ ならない唯一のプロンプトは
ディスクの交換をユーザーに求めるものもある。ディスク側とゲームの種類はゲーム側で指定されるため関係なく、ユーザー側 で
FDS エミュレータでゲームのアクションを再開するには、ボタンを 1 つ押すだけです。
独自の FDS ディスク コール エミュレータを作成したくないが、ロード/保存時間の短縮を望む、それほど野心のないエミュレータ作成者に は、次の提案があります。ROM BIOS
ディスク サブルーチンは、ディスクとの間でバイトを転送するたびに待機ルーチン (IRQ を待機) を呼び出します。これを解決す るには、待機ループの分岐先を変更して、ディスク
データの読み取り/書き込み用の IRQ ハンドラに直接分岐するようにします。この方法では、6502 エミュレーションが許す限り高速にデ ータにアクセスします。ロ
ード/保存時間を短縮するもう 1 つの方法は、6502 クロックの数を制限しないことです。
ディスク呼び出し中に発生するフレームあたりのサイクル数。
**************************************************
*FDS ディスクドライブの動作の簡単な説明* **************************************************
FDS ディスク ドライブから出力されるデータは、ヘッドが現在読み取っているデータのリアルタイム表現です。つまり、デ ータのフォーマットは行われません。ヘッドは常に
一定の速度でディスク上を移動しています。
(シーケンシャルアクセス)ディスクが回転するにつれてヘッドがディスクの終わりに到達すると、 ディスク(最も内側のトラック)を越えると、ディスクの先頭(最も外側のトラック)に戻ります。

 Machine Translated by Google
トラック単位での読み取りが行われ、RAM アダプタからの要求に応じてこのサイクルが繰り返されま す。つまり、スキャンのたびにディス
ク全体が読み取られます (約 6 秒かかります)。
ディスク ドライブは、ヘッドが最も外側のトラックに配置され、新しいスキャンを開始すると、RAM アダプタに信号 を送ります。
****************************
*FDSデータ転送プロトコル* ****************************
あらゆるデータ転送では、次の 2 つの情報 (信号) を送信する必要があります。
‐ データが送信される速度を表す信号 ‐ 実際のデータ
ほとんどのディスク ドライブ ユニットと同様に、FDS ディスク ドライブはシリアル接続 (1 本のワイヤ、つまり 1 ビットずつ) を介 してデータを送信します。FDS ディス
クに事前に記録されたデータには、すでに、以下で説明する XOR アルゴリズムを使用して、前述の 2 つの信号が「結合」されてい ます (以下の図では、0 と 1 の論理レベ
ルを表すために、それぞれアンダースコア (_) とハイフン (‐) を使用していることに注意してください)。
レート ‐‐‐‐____‐‐‐‐____‐‐‐‐____‐‐‐‐____‐‐‐‐____‐‐‐‐____‐‐‐‐ ____‐‐‐‐____‐‐‐‐____
データ ________‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐______________________________________‐‐‐‐‐‐‐‐‐
____‐‐‐‐____‐‐‐‐‐‐‐‐____‐‐‐‐____‐‐‐‐________‐‐‐‐‐‐‐‐ ________‐‐‐‐____‐‐‐‐
ディスク ____‐_______‐__________‐_______‐__________‐ _______________‐_______‐___
排他的論理和

 Machine Translated by Google
時間 ‐‐‐>
レートは、データ(ビット)が転送される間隔を表す信号です。この信号の0から1(_‐)への遷移ごとに、1つのデータビットが転送されます。 RAMアダプタは96.4kHzの転送速
度を想定していますが、この速度に対する許容範囲は10%です。この許容範囲は
ディスク ドライブはデ ィスクを一定速度で回転させることができないため、これが必要です。一定に見えても、物理的な構造上、回転速度にはわずかなばらつきが あります。
データは、シリアル化される目的の連続バイナリ データです。
ここで使用したデータは、それが どのようになるかを示すために特に選びました。
FDSに保存される ディスク。データが変更された場合、0から1への変更と同期して変更されることに注意してください。
(_‐) レート信号の遷移。 XORは、レートに対して実行された論理排他的論理和の結果を表します。 およびデータ信号。
ディスクは、FDS ディスクに実際に記録されているもの (つまり、ディスク ドライブから出力され、RAM アダプタに送られる内容) を表します。この 信号は、XOR 結果信号の 0 から 1
(_‐) への遷移ごとに同期して書き込まれるパルスで構成されています。実際には、これらのパルスの長さ (1 のままの時間) は約
1 マイクロ秒です。RAM アダプタがディスクに書き
込むためにデータを送信する場合も、この形式になります (ただし、上記の図とは論理的に反転しています)。ただし、RAM に送信されるデータは、
アダプタはこの形式である必要はありません。RAMアダプタは

 Machine Translated by Google
パルスの長さではなく、シリアル データ信号内の 0 から 1 (_‐) への遷移を重視します。これが、RAM アダプタが両方のシリアル データ タイプ (XOR またはディスク) を
区別せずに解釈する理由です。
***********************************
*FDS ディスク磁気エンコード形式* ***********************************
FDS ディスクにデータを磁気的に保存するシステムは非常にシンプルです。ディスク ヘッドがディスクを読み取っているときはいつでも、デ ィスク領域の現在のセクション
にどのような磁荷があるかを知る方法はありません (したがって、ヘッドは電圧を生成しません)。磁気誘導の物理的な仕組みにより、
ヘッドは反対の電荷を含むディ
スク トラックのセクションを読み取っている間だけ電圧を生成します。この間、ヘッドは電圧のスパイクを生成します (スパイクの持
続時間は、ヘッドの幅 (ディスクの表面に
物理的に接触している領域) とディスクの回転速度の関数です)。これらのスパイクは増幅され、ドライブのデータ出力ピンに送信 されます。これが、FDS ディスク上のデータ
エンコーディングが行われる方法です。次の図で詳しく説明します。
ポール \_____/
_____ _____ _____ _______/ _______/
データ
時間 ‐‐‐>
POL は、一般的なディスク トラック上の磁荷の極性を表します。
データはPOLの変化の解釈であり、デジタルでもある。
‐_____‐_____‐_____‐_____‐_____‐_____

 Machine Translated by Google
その結果、ドライブの「データ出力」信号に表示される信号です。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|磁気的にディスクにデータを記録する| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
ディスクに書き込むためにディスク ドライブに入力されるデータは、直接書き込まれるわけではありません。RAM アダプタと同 様に、ディスク ドライ
ブのデータ入力は、そこに送られるパルスの正のエッジに応答します。
これは、データが内部のポジティ
ブエッジトリガートグルフリップフロップ(2分周カウンタ)に入力されるためです。このフリップフロップの出力状態は次の ようになります。
ディスク書き込み中にドライブの書き込みヘッドに送られる信号。2本の書き込みヘッド線は
フリップフロップの相補出力は、書き込みフェーズでは常に反対の状態になるようにします。書き込み中は、流れる電流が
書き込みヘッドを通過する電流(どちらの方向でも)は約 20 ~ 25 ミリアンペアです。 次の図は、これらの信号間の関係を概説したものです。
ディン
‐‐‐‐__‐‐__‐‐____‐‐__‐‐‐‐______‐‐____‐‐‐‐
W1
W2
時間 ‐‐‐>
______‐‐‐‐______‐‐‐‐__________‐‐‐‐‐‐____ ‐‐‐‐‐‐____‐‐‐‐‐‐____‐‐‐‐‐‐‐‐‐‐______‐‐‐‐
Din は、ディスクに書き込まれることを目的としてドライブに入るデータです。

 Machine Translated by Google
W1 と W2 は、ディスク ドライブの書き込みヘッドに接続されたワイヤのデジタル状態を表します。
************************************
*低レベルのディスクデータレイアウト/ストレージ* ************************************
使用される通信プロトコルについて説明したので、次はディスク上のデータ構造のレイアウトについて説明します。Nori のドキュメント には、RAW データがディスク上にレ
イアウトされる方法についての情報がわかりやすく記載されています。
この時点で、Nori の「fds‐nori.txt」を参照して、ディスク データ構造について説明しているドキュメントの前半を読むことをお勧めします。
ここで、前述の文書に記載されているいくつかの項目について詳しく説明したいと思います。ビットまたはバイトのデータ転送に関する言 及は、
標準 96.4kHz 転送ビット レート (1 ビットが 1/96400 秒で転送されることを意味します)。
‐ ディスクドライブユニットは、ヘッドがRAMアダプタに移動したときに信号を送ります。
ドライブは、ディスクの先頭から「‐ready」信号を送信します (詳細は後述)。「‐ready」信号は、ドライブ内部の機械スイッチに基づいてお り、ヘッドがディスクの最も外
側の端 (先頭) に戻ったときにアクティブになります。通常、スイッチは予定より早くトリガーされるため、このスイッチがアクティブになった 直後にドライブが送信するデータの
最初の 13000 ビット (約) は無効になります。
これを補うために、RAM アダ
プタはディスク ドライブから「‐ready」信号を受信してから、送信された最初の 26100 ビット (約) を意図的に無視します。

 Machine Translated by Google
‐ この期間が過ぎると、RAM アダプタはディスクから読み取ったデータを解釈します。これらのディスク ドライブ ユニッ トには多くの機械的変数があるため、ディスクに記
録されたデータは、RAM アダプタがデータの受信を開始する正確な時点を予測できません。
したがって、ここでは「GAP」期間と呼ばれるパ ディング メカニズムが使用されます。
‐ ディスクに記録されたすべてのギャップ期間は、バイナリコード化された0で構成されています。RAMアダプタは、ファイルの開始を識別するセ ット(1)ビットを受信するまで、こ れらの0を無視します(つまり、ディスクに記録されたギャップ期間にはサイズ制限がありません)。Noriのドキュメントでは、
「ブロック開始マーク」と呼ばれる。このビットの直後のデータがファイルデータを構成します。ファイルのサイズは、読み込まれたファイルデ ータによって決まります。
(Nori のドキュメントを参照してください)。ファイルのデータが終了する場所を示すメカニズム (ファイルの先頭の場合など) が実 際には実装されていないため、これがファ
イルのサイズを決定する唯一の方法であることに注意してください。
‐ シリアル バイナリ データがディスクに記録される順序は、リトルエンディアン形式です。下位ビットが上位ビットの前に最初に送信され、バ イトについても同様で
す。
‐ 一般的な FDS ディスク上に存在する最初の GAP 期間の長さ (ディスク ドライブの「‐ready」信号がアクティブになった瞬間を基準とし て) は約 40000 ビットであり、その
後に最初のブロック開始マーク (最初のファイルの開始を示す) が表示されます。

 Machine Translated by Google
‐ ディスクへの書き込みは、ディスク上の既存のデータと同期して行われません。書き込み期間の開始と終了の場所 は、ほとんどの場合、無効な長さのパルス間
のギャップを作成するため、悪いニュースです。これにより、
RAMアダプタがデータを誤って解釈し、エラーを引き起こすことがあります。これを克服するために、RAMアダプタは常に最初の 488ビット(約)を無視しま
す。
ファイルの直後。この期間に、RAM アダプタ (またはゲーム) はディスクからの読み取りから書き込みへ、またはその逆へ切り替える 機会を得ます。
‐ この期間の後、アダプタは別のギャップ期間を予想し、その後ブロック開始マーク ビットと次のファイルに進みます。
このサイクルは、ディスクに配置するフ ァイルがなくなるまで繰り返されます。
‐ FDS ディスク上のファイル間で使用される一般的な GAP 期間のサイズは、およそ 976 ビットです (これには、RAM アダプタによっ て無視されるビットが含まれ
ます)。
‐ 最後のファイルが記録された後、ディスクの残りの部分は0で埋められます (ただし、この後ディスク上に何が存在するかは実際には問題ではありません)。
******************
*CRC計算* ******************
FDS で使用される CRC アルゴリズムの解読に協力してくれた Val Blant に特に感謝します。
「ブロック終了マーク」は、各ファイルの直後に追加されるCRC計算です。計算は、そのファイルのデータのみに基づいて行わ れます。

 Machine Translated by Google
CRCは16ビットで、17ビットポリで生成されます。使用されるポリは10001000000100001b(X25標準)です。右シフト演算は、
CRCを計算します(これは、
多項式は、8408hの16ビット多項式になります。x86の例を以下に示します(;は1行に複数のステートメントを区切るために使用され、// はコメントとして使用されます)。こ
のアルゴリズムが機能するように設計されたファイルには、
ブロック開始マーク($80)がなく、末尾に2バイト(CRC計算が通常格納される場所)があり、0になっています。ブロック開始マークは
マークは実際には FDS ファイルの CRC の計算に使用されますが、以下のアルゴリズムでは、ブロック開始マーク数量 ($80) がレジ スタに直接移動されることが
わかります。
// ax は CRC アキュムレータとして使用されます // siは配列要素のカウンタです
// di は一時レジスタです
// サイズはファイルのサイズ + 2 (最後の 2 バイトは 0)
// Buf はファイルデータを指します(2 バイトが追加されます)
mov ax,8000h // これはブロックの開始マークです
sub si,si // ファイルバイトインデックスポインタをゼロにする
@1: mov dl、バイトポインタBuf[si] インクsi
shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および shr dl、1; rcr斧、1; sbb di、di;および
di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di di,8408h; xor ax,di

 Machine Translated by Google
cmp si、サイズ jc @1
// ax に CRC が含まれるようになりました。
もちろん、この例は CRC アルゴリズムがどのように機能するかを示すためだけに使用され ます。 事前に計算されたCRCルックアップテーブルを使用すると、ループ内でCRCを計算するためのはるかに高速な(約5cc/it)方法です(上記の 方法では40クロック以上を消
費します)。
サイクル/反復)。ただし、速度が問題にならない場合は、上記のコード
テーブル検索の実装で消費されるメモリのほんの一部しか使用しません。多項式の値をレジスタにロ ードすることで、さらに多くのメモリを節
約できます。また、繰り返しの命令を 2 番目のループにまとめることで、さらに多くのメモリを節約できます。
************************************
*FDS RAMアダプタ制御信号* ************************************
元々ここにはなかった追加の FDS 配線情報を提供してくれた Christopher Cox 氏に特に感謝します。
ろろろろろろ
lo ...
lo ...
ろろろ1 3 5 7 9Bロロロ
ろろろ ろろろ ろろろ2 4 6 8ACロロロ
lo ...
lo ...
RAM アダプタのディスク ドライブ コネクタの開いた端のビュー。

 Machine Translated by Google
ピン番号 *2C33ピン*RAMピン信号の説明 ‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
1 50 2 64
3 49
4 32
5 52
6 37
7 47
5 (緑)(O) ‐書く
C (シアン) (O) VCC (+5VDC) 6 (青) (O) ‐スキャンメディア
1 (茶)(O) VEE (地)
3(オレンジ) (O) データを書き込む B (ピンク) (I) モーターオン/バッテリー良好
8 (グレー) (I) ‐書き込み可能なメディア
8
9 51
あ 45 B 46 C 48
記号に関する注釈 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
(O): 信号出力。 (I): 信号入力。
(I)モーター出力(注1) 4(黄色) (I)データを読み取る
(黒)(I) ‐メディアセット
9 (白)(I) ‐準備完了
7(紫) (O) ‐モーターを停止
‐‐
‐ : ロー(0)状態でアクティブになる信号を示します。
* : これらは2C33 I/Oチップの対応するピン配置であり、もう一方の端は
RAM アダプタ ケーブルの、両方とも RAM アダプタ内にあります。
1: RAM アダプタはこの信号を使用しません (ケーブル内に信号を伝送するワイヤはありません)。ディスク ドライブ ユニット内の電 子制御 5 ボルト電源が、ここに表示さ
れる電力を生成します。この電力は、ドライブの内部電気モーターにも使用されます。
したがって、このピンに電圧 がかかっている場合にのみモーターがオンになります。
(O) ‐書く ‐‐‐‐‐‐‐‐‐‐
この信号がアクティブな場合、"書き込みデータ" 信号ピンに表示されているデータがストレージ メディアに書き込 まれることを示します。
(O) データを書き込む ‐‐‐‐‐‐‐‐‐‐‐‐‐‐

 Machine Translated by Google
これは、RAM アダプタが「‐write」条件でストレージ メディアに書き込むために発行するシリアル データです。
(O) ‐メディアをスキャン ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
非アクティブの場合、ストレージメディアポインタはメディアの先頭でリセットされ(リセットされたまま)、アクティブの場合、メ ディアポインタは一定の速
度で進み、データは徐々に転送されます。
メディアとの間で(メディア ポインタ経由)。
(O) ‐モーターを停止 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
主に FDS ディスク ドライブ ユニットにのみ適用され、この信号の立ち下がりエッジは、ドライブにディスクの現 在のスキャンを停止するように指示しま
す。
(I) モーターオン/バッテリー良好 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
主にFDSディスクドライブユニットにのみ適用されます。RAMアダプタが「‐scan media」信号を発行した後、この入力の状態をチ ェックして、ディスクド ライブモーターがオンになっているかどうかを確認します。この入力がオンになっていることが判明した場合、
非アクティブの場合、RAM アダプタはこれをディスク ドライブのバッテリが故障したと解釈します。基本的に、この信号の動 作は、TTL 信号バ
ージョンであることを除いて、上記の「モーター電源」信号と同じです。
(I)書き込み可能なメディア ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
この信号がアクティブの場合、現在のメディアが書き込み保護されていないことを RAM アダプタに通知します。
(I)データを読み取る ‐‐‐‐‐‐‐‐‐‐‐‐‐

 Machine Translated by Google
「‐scan media」が有効な場合、メディアから徐々に読み取られるデータは ストレージ メディア (メディア ポインタ経由) がここに表示されることが予想されます。
(I)メディアセット ‐‐‐‐‐‐‐‐‐‐‐‐‐‐
この信号がアクティブの場合、有効なストレージ メディアが存在することを示します。
(私は準備ができている ‐‐‐‐‐‐‐‐‐‐
主にFDSディスクドライブユニットにのみ適用され、この信号の立ち下がりエッジはRAMアダプタにディスクドライブ が
「‐scan media」信号を認識し、ディスク ドライブ ヘッドは現在ディスクの先頭 (最も外側のトラック) にあります。この信号がアク ティブな間は、ディスク ヘッドがディス クの表面を移動しており、適切なデータをディスクに転送できることを示します。ヘッドがディスクの末尾まで移動すると、この信号は非 アクティブになります。
(最も内側のトラック)、または「‐scan media」信号が非アクティブになります。
***********************************
*ディスクドライブをエミュレートする手順* ***********************************
RAM アダプタとディスク ドライブ/ストレージ メディア間のデータ転送を開始する前に、いくつかの制御信号が評価され、 送信されます。
イベントが発生する順序は次のとおりです。
1. 「‐media set」は他のシグナルの前に検査されます。 ストレージメディアが挿入
されているときにこの入力を有効にします。転送中(および転送後もしばらく)この入力が有効になっていることを確 認してください。

 Machine Translated by Google
そうでない場合、FDS BIOS はエラー #1 (ディスク セット) を報告します。この信号がアクティブではなく、データ転送が要求された場合、 BIOS はこの信号がアクティブに
なるまで待機してから、制御信号の送信/検査を続行します。
2. RAMアダプタが転送中にメディアへの書き込みを試行する場合は、「書き込み可能なメディア」入力をアクティブにしてください。 そうしないと、FDS BIOSはエラー#3
(ディスク書き込み保護)を報告します。実際の
ディスクドライブでは、「‐書き込み可能なメディア」が同時にアクティブになります「‐ メディアセット」が行う処理(書き
込み保護されていないディスクがドライブに挿入された場合)です。いくつかの FDS ゲームはこれに依存しているため、書き込み可能な ディスクの場合は、「‐
「書き込み有効」フラグは「‐
media set」と同時に有効にする必要があります。
3. RAM アダプタは、"‐scan media"=0 および "‐stop motor"=1 を設定して、ストレージ メディアに転送の準備を指示しま す。これは、最初の 2 つの条件が満たされた場
合にのみ発生します。
4. 次に「モーターオン/バッテリー良好」を調べます。この入力は常にアクティブにしておいてください。そうしないと、FDS BIOS はエラー #2 (バ ッテリー残量不足) を
報告します。
5. 「‐ready」を有効にすると、メディア ポインタが現在メディアの先頭に位置し、進行中であることが RAM アダプタに通知されます。この 信号がアクティブになっている間に、
メディア データの転送/交換が行われます。転送中はこの入力がアクティブになっていることを確認してください。そうでない場合、FDS BIOS はエラーを報告します。"‐
ステップ 3 から少なくとも 14354 ビットの
転送 (約 0.15 秒) が経過するまで、「ready」をアクティブ化しないでください。

 Machine Translated by Google
6. 転送中、RAM アダプタからの「‐write」信号はデータ転送方向を示します。非アクティブの場合、メディアから読み取られたデータ は「read data」信号に表示されます。ア
クティブの場合、「write data」信号に表示されるデータはメディアに記録されます。
7. RAM アダプタは、メディアから十分なファイルまたはすべてのファイルを読み取った時点で、データ転送を終了します。これは、「‐ scan media」=1 または「‐stop motor」=0
のときに実行されます。この後、「‐ready」信号を非アクティブにして、すべてのメディア I/O 操作を停止しても問題ありません。
+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
|最後にいくつか注意事項| +‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
‐ 「‐scan media」がアクティブ化された後、メディアがデータ転送の準備をする時間を必要としない場合は、「‐ready」を「‐scan media」信 号に結び付けても問題あり
ません。 「‐ready」を常にアクティブにしないでください。これは私がテストしたディスクゲームの95%で機能しますが、「‐
転送後、「ready」は 無効になります。
‐ 一部のライセンスのない FDS ゲームでは、メディア転送を中止するときに「‐stop motor」信号 (および、ストレージ メディアが書き込み対象で はない場合でも「‐write」)
がアクティブになり、「‐scan media」がまだアクティブになります。これは非正統的な方法ですが、この状況に対処する最善の方法は、「‐stop motor」信号を他の信号よりも
優先し、アクティブ化中にデータ転送を強制的に終了することです。
‐ 私のFDSローダープロジェクトをチェックしてください(*.FDSファイルをRAMにアップロードします)

 Machine Translated by Google
動作するディスク ドライブ エミュレーターのソース コード用のアダプターです。
****************************************************
*通常は起動しない FDS ディスク ゲームを起動する* ****************************************************
FDS ローダー プロジェクトを終えた後、通常は動作しない FDS ゲームを正常に起動する方法を発見しました。これを行 う秘訣は、ディスク ドラ
イブ メカニズム自体の一部にあります。
ディスクをドライブに挿入すると、ディスク ベイが下がり、最終的に磁気フロッピーの下側がヘッドに接触します (ヘッドは一定の 高度にあります)。磁気フロッピーの上面では、ブラシの付いた何らかのアームがフロッピーの表面に下がり、フロッ ピーをヘッドに押し付け
て、ヘッドとのより密接な (またはより良好な) 接触を可能にします。
このブラシアームに少し力を加えると、いつも起動しないディスクゲームが起動するようになることがわかりました。ただし、力 を入れすぎるとブラシの摩擦で
速度が遅くなります。
ディスクの RPM が不足しており、転送速度が範囲外となるため、RAM アダプタはディスクから起動できません。
これを永久的に解決するには、すでに入っているスプリングの張力を高めることです。スプリングを取り外すには、スプリ ングが巻き付いているピン
(アームを支えるピンでもある) を外す必要があります。ドライブの前面を自分の方に向け、右側からピンを削って外しま す。

 Machine Translated by Google
スプリングのトルクを再度調整する必要がある。
巻き線を回転させると、張力が強すぎます。両手を使って (ラジオペンチを使用する必要があるかもしれません)、スプリングを、圧力をか ける方向と同じ方向にねじってく
ださい。
これにより、スプリン グのコイルの半径が大きくなります。
再度トルクをかける必要があります。必要なのは手の力だけです。これで、スプリングをドライブに戻す準備が整いました。スプリング をピンに戻すのは少々難しいので(ア ームが邪魔になるので)、忍耐が必要です。元に戻すのが簡単そうに思える場合は、スプリングの巻きに十分な回転を加えていないこと を意味します。
いずれにせよ、スプリングを戻した後に加える力が、取り外したときよりもかなり大きくなるようにしてください。
ブラシ アームのスプリングを調整/交換せずに、フロッピーに対してブラシ アームが加える圧力を増す簡単な方法としては、アームに テープで重りを貼り付ける方法が
あります (たとえば、数枚の 1 セント硬貨や 10 セント硬貨で十分な重さになります)。個人的には、スプリングのトルクを再度調整する前にこ れを試しましたが、あまりうまく
いきませんでした (主にテープが常に何かに当たっていたためです)。
一部のゲームはデフォルトの圧力で動作するのに対し、他のゲームではそれ以上の圧力が必要な理由については、 問題のディスクの表面
が波打っており、おそらく何年も使用した後にそのままになっているのではないかと推測します。
十分な圧力がなければ、頭部が 接触するのは波紋だけとなり、

 Machine Translated by Google
読み取りに必要な接触面積のほんの一部に過ぎない。
磁気データを確実に取得します。
しかし、私の言うことを鵜呑みにしないでください。起動する FDS ディスクの表面を見て、起動しないディスクと比べてみま しょう。正常に動作するディスクの表面は均一
ですが、その他のディスクには摩耗の跡が見られます。摩耗のほとんどはディスクの端 (最も内側のトラック) に現れます。摩耗が端 に現れるのは、ディスク スキャンのたび
にディスク ヘッドが停止する場所だからです。
*******************************
*コピープロテクトの回避* *******************************
ハードウェアディスクコピー保護 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
どうやら、任天堂はFDSディスクドライブユニットを、ディスク全体を再プログラムできないように設計していたが、それでも ディスクの最後に個々のファイル のコンテンツを書き込むことは可能だったようだ。現在、文書化されていないものが多くある。
ディスク ドライブ ユニット内部で起きていることは、すべて説明済みです。FDS ディスク ドライブ内部には、3213 と 3206 という 2 つの悪質な IC があるので、注意が必要で
す。NESdev には、6 つの "FDS‐COPY" jpeg コレクションがあり、これ (4 ページ右側と 5 ページ) には、標準の FDS ディスク ドライブを改 造してディスクを再プログラ
ムする手順の概要が、非常にわかりやすく図解されています。jpeg で説明されている特定の回路は作成していませんが、FDS の悪質なコピ ー防止回路を無効にする同様の回路
を設計して作成し、素晴らしい結果を得ました。

 Machine Translated by Google
ソフトウェアディスクコピー保護 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
このことを私に知らせてくれた Chris Covell 氏に特に感謝します。
どうやら、一部のFDSディスクは非常に単純なコピー保護スキームを実装しており、ゲームはそれに依存して、そのディ スク上でゲームが動作しないようにし
ているようです。
コピーされたディスク。通常、FDS ディスクに存在するファイルの数は、ディスクに記録されている 2 番目のブロックに格納され ます。ただし、一部のゲ
ームでは「不可視」ファイル、つまりファイル カウント ブロックのファイル カウント数を超えて存在するファイルが存在 することがあります。これは、
FDSLOADR のようなコピー ソフトウェアでは、問題になります。これらのツールはファイル カウント ブロックに依存し
ており、ディスク上で見つかった
最後のファイルの後に有効なデータがあるとは想定していないためです。つまり、これらの種類のディスクをコピーする
と、非表示のファイルが失
われ、ゲームが存在するファイルをロードするときに、ファイルが見つからないなどの理由でゲームがユーザーを怒らせ、作 業が妨げられま
す。ただし、実際には、FDS ディスクがプログラムされると、ディスクの未使用の末尾は通常完全にゼロに書き込まれるた め、ディスクの末尾の検出は簡
単になります。非常に長い GAP 期間が見つかるまで待つだけです。まれな場合を除き、FDS ディスクの真の末尾を検出す るこのモデルは、すべての
種類の FDS ディスクの完全な内容をコピーする場合に通常最良の結果をもたらすはずです。
物理ディスクのロックアウトメカニズム ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐

 Machine Translated by Google
任天堂がなぜすべてのFDSディスクのハンドルの端に社名を刻んだのか不思議に思ったことはありませんか?FDSディスクドライ ブベイの内側、前面の黒いプラス
チックのフェースプレートの下部のすぐ後ろには、硬質プラスチックのブロックから「Nintendo」の文字が彫り込まれた小さなプラ スチックブロックがあ
ります。これは基本的に、その場所に穴のないディスクがドライブに完全にロードされないようにし、使用を回避します。多くの会社 がそれらの穴を切り取った
FDSディスクを製造していますが、
FDSと互換性があるが穴がないディスクもあります。そのため、解決策は、FDSディスクドライブを分解し、ディスクケージ を取り外し、「Nintendo」を
固定している2本のネジを外すだけです。
レターブロック。
**********************
*ROM BIOS 分解* **********************
6502コードであるDCC6502を提供してくれたTennessee Carmel‐Veilleux氏に特別な感謝を申し上げます。 彼が書いた逆アセンブラをここでの逆アセンブルに使用しました。
分解に関する注意事項 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
‐ 下のような表は、実際のROM(ビッグエンディアン)に表示されるバイト(16進ペア)を表示します。マルチバイトの数字のみ
「$」で始まる文字列はリトルエンディアン形式で保存されます。
‐ このコード内のいくつかのサブルーチンは、ハードコードされたパラメータ(JSR命令に続く命令ストリー ムに格納されたデータ)を操作します。

 Machine Translated by Google
ハードコードされたパラメータを使用するサブルーチンでは、JSR $xxxx の後にカンマと実際のハードコードされた(即時の)データが 表示されます。
もちろん、サブルーチンは戻りアドレスを調整して、プログラム制御がハードコードされたパラメータの後のアド レスに戻るようにします。
‐ すべてのコードにコメントが付けられているわけではありませんが、私が見つけることができたディスク I/O 関連の サブルーチンをすべて
徹底的に調べ、その動作を理解しやすくするために適切なコメントを (できれば) 付けました。
; ロイヤリティフリー ... ろろろろ
;ろろろろろろろろろろろろろろろろ FDS ROM BIOS 逆アセンブリ lo ...
; ロイヤリティフリー ... ろろろろ
$E000
DB00
;フォントビットマップ 384CC6C6C66438001838181818187E00 7CC60E3C78E0FE007E0C183C06C67C00 1C3C6CCCFE0C0C00FCC0FC0606C67C00 3C60C0FCC6C67C00FEC60C1830303000 7CC6C67CC6C67C007CC6C67E060C7800 386CC6C6FEC6C600FCC6C6FCC6C6FC00 3C66C0C0C0663C00F8CCC6C6C6CCF800 FEC0C0FCC0C0FE00FEC0C0FCC0C0C000 3E60C0DEC6667E00C6C6C6FEC6C6C600 7E18181818187E001E060606C6C67C00 C6CCD8F0F8DCCE006060606060607E00 C6EEFEFED6C6C600C6E6F6FEDECEC600 7CC6C6C6C6C67C00FCC6C6C6FCC0C000 7CC6C6C6DECC7A00FCC6C6CEF8DCCE00 78CCC07C06C67C007E18181818181800 C6C6C6C6C6C67C00C6C6C6EE7C381000 C6C6D6FEFEEEC600C6EE7C387CEEC600

 Machine Translated by Google
6666663C18181800FE0E1C3870E0FE00 000000000000000000000000030302000 00000000303000000000000006C6C0800 3844BAAAB2AA4438
;131 クロックサイクル遅延 遅延131:PHA
$E14A LDA #$16
SEC $E14D SBC #$01
$E14F BCS $E14D
$E14C
$E151 $E152
人民解放軍 RTS
;ミリ秒遅延タイマー。クロックサイクルの遅延は 1790*Y+5 です。
ミルセックタイマー: LDX $00 $E155 LDX #$fe
$E157
$E158
$E159 BNE $E157 150億ユーロ CMP$00
$E15D $E15E $160 円
デックス
デイ
BNE ミルセックタイマー RTS
いいえ
;プレイフィールドとオブジェクトを無効にする 表示オブジェクト:LDA $FE
$E163 そして #$e7
$E165 STA $FE
$E167 STA $2001;
[NES] PPU セットアップ #2
$E16A
RTS
;プレイフィールドとオブジェクトを有効にする EnPfOBJ: LDA $FE
$E16D オラ #$18
$E16F BNE $E165
;オブジェクトを無効にする DisOBJ: LDA $FE
$E173 そして #$ef $E175 JMP $E165
;オブジェクトを有効にする EnOBJ: LDA $FE

 Machine Translated by Google
$E17A オラ #$10 $E17C BNE $E165
;プレイフィールドを無効にする DisPF: LDA $FE
$180 円 かつ #$f7 $E182 JMP $E165
;プレイフィールドを有効にする
エンPF:
$E187 オラ #$08 $E189 BNE $E165
; ロイヤリティフリー ... ろろろろ
;NMI プログラム制御 ...
; ロイヤリティフリー ... ろろろろ
;このルーチンは、[$0100]に基づいて、NMIで発生するアクションを制御します。
;[$0100] NMIでのプログラム制御 ;‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
;00xxxxxx: VINTwait を呼び出しました
;01xxxxxx: ;10xxxxxx: ;11xxxxxx:
;NMI分岐ターゲット NMI: ビット $0100
VINTwaitが呼び出されました。そのアドレスにPCを戻します。
[$DFF6]ベクトルを使用する [$DFF8]ベクトルを使用する [$DFFA]ベクターを使用する
$E18E $190 円 $E192 $E195 $E198 $E19A
BPL $E198
BVC $E195
JMP ($DFFA); 11xxxxxx JMP ($DFF8); 10xxxxxx BVC $E19D
JMP ($DFF6); 01xxxxxx
LDA $FE
;それ以上のVINTを無効にする 00xxxxxx $E19D LDA $FF

 Machine Translated by Google
$E19F $E1A1 $E1A3 $E1A6
そして #$7f
スタ $FF
STA 2000ドル [NES] PPU セットアップ #1 LDA 2002ドル; [NES] PPUステータス
;中断された戻りアドレスを破棄します($E1C5である必要があります)
$E1A9 $E1AA $E1AB
人民解放軍 人民解放軍 人民解放軍
;[$0100]のバイトを復元
;Aを復元 $E1B0 $E1B1
$E1AC
人民解放軍 $E1AD STA $0100
人民解放軍 RTS
;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
;VINTを待つ VINTwait:PHA; Aを保存
$E1B3 LDA $0100
$E1B6 PHA; 古いNMIプログラム制御バイトを保存
$E1B7 LDA #$00
$E1B9 STA $0100;
;VINTを有効にする
$E1BC LDA $FF $E1BE オラ#$80 $E1C0 スタ$FF $E1C2 STA 2000ドル
;無限ループ
$E1C5 BNE $E1C5
; ロイヤリティフリー ... ろろろろ
;IRQ プログラム制御 ro ...
; ロイヤリティフリー ... ろろろろ
[NES] PPU セットアップ #1
NMI pgm ctrl バイトを 0 に設定する

 Machine Translated by Google
;このルーチンは、[$0101]に基づいて、IRQで発生するアクションを制御します。
IRQ: ビット $0101 $E1CA BMI $E1EA $E1CC BVC $E1D9
;ディスク転送ルーチン ([$0101] = 01xxxxxx) $E1CE LDX 4031ドル
$E1D1 STA $4024
$E1D4 $E1D5 $E1D6 $E1D7 $E1D8
人民解放軍 人民解放軍 人民解放軍 TXA RTS
;ディスク バイト スキップ ルーチン ([$0101] = 00nnnnnn; n はスキップするバイト数)
;これは主にCPUがバイトを処理している間に何らかの計算を行う必要がある場合に使用されま す。
;ディスクから読み取ったデータは破棄する必要があります。
PHA $E1DA LDA $0101
$E1D9
SEC $E1DE SBC #$01
$E1E0 BCC $E1E8 $E1E2 STA $0101 $E1E5 LDA $4031
$E1DD
$E1E8 $E1E9
人民解放軍 RTI
;[$0101] = 1Xxxxxxx
$E1EA BVC $E1EF
$E1EC JMP ($DFFE); 11xxxxxx
;ディスクIRQ確認ルーチン([$0101] = 10xxxxxx)。 ;これが何のために使用されるのか、なぜここに遅延が置かれているのかはわかりません。
PHA $E1F0 LDA $4030
$E1EF
$E1F3 JSR 遅延131
$E1F6 $E1F7
人民解放軍 RTI

 Machine Translated by Google
; ロイヤリティフリー ... ろろろろ
;ファイルを
読み込む コンテンツ ...
; ロイヤリティフリー ... ろろろろ
;ディスクからメモリにファイルを読み込みます。
;パラメータ
;‐‐‐‐‐‐
;RETaddr 10バイトのディスクヘッダー比較文字列へのポインタ ;RETaddr+2 識別してロードするファイルのリストへのポインタ
;ディスクヘッダー比較文字列は最初の10バイトと比較され、
;一致するものがあれば、 最初のブロックに「*NINTENDO‐HVC*」という文字列があります。 ;失敗の場合、エラーが発生します。比較文字列に‐1が含まれている場合、
;特定のバイトのテストをスキップします。通常、この文字列は
;ディスク面と番号データが正しいことを確認します。
ファイルIDリストは、ディスクからロードされるファイルのリストです。
ディスクは
;ID番号(各1バイト)は、
;ディスク上の個々のファイルと、特定の ;ファイルがメモリにロードされています。リストには20個のIDが含まれていると想定されていますが、 ;‐1 を文字列の末尾に置くと検索を終了できます
;早すぎる。文字列の最初のIDが‐1の場合、これはシステムが ;ブートが開始されます。ブートファイルは最初のコードでロードされます。 ;ディスクのブロック。このBootIDコードに一致するかそれより小さいファイルは
結果的に
ブートID

 Machine Translated by Google
;ロードされるもの。一致するファイルが見つかるたびに、カウンターが ;増加します。ロードが完了すると、このカウントはファイルの数を示します。
;見つかりました。見つかったファイル数に関するエラー チェックは行われません。
;最初の試行でエラーが発生した場合、サブルーチンは追加の
; 0 以外のエラー コードを返す前に、ディスクの読み取りを試行します。
;Aにエラー番号(ある場合)を返し、見つかったファイルの数を Y.
ロードファイル:
$E1FA STA $0E
$E1FC LDA #$ff;2つの16ビットポインタを取得
JSR 取得HCPwNWPchk $E201 LDA $0101
PHA
$E1FE
$E204
$E205 LDA #$02;エラー再試行回数 $E207 STA $05
$E209 JSR $E21A
$E20C BEQ $E212;
$E20E DEC $05; 再試行回数を減らす $E210 BNE $E209
$E216 LDY $0E
エラーが発生した場合の返信先
$E212
人民解放軍 $E213 STA $0101
$E218 $E219
TXA RTS
LDA #$00
JSR チェックディスクヘッダー
$E21A
$E21D JSR Get#ofFiles;[$06] に # を返します
$E220 LDA $06
$E222 BEQ $E233; 何もない場合は全てスキップする $E224 LDA #$03
$E226 JSR チェックブロックタイプ
$E229
$E22C
$E22F 12月 $06
JSR ファイルマッチテスト
JSR ロードデータ

 Machine Translated by Google
$E231 BNE $E224
$E233 $E236
JSR 転送完了 RTS
; ロイヤリティフリー ... ろろろろ
;ファイルを書き込んでファイル数を設定する rot ...
; ロイヤリティフリー ... ろろろろ
;ディスクの最後の位置に1つのファイルを書き込みます。 ;ディスクのファイル数。ヘッダー比較文字列とファイルヘッダーへのポインターを使用します ;構造体(SaveData サブルーチンで説明)。
;これはROM BIOSがデータを書き込むために提供する唯一のメカニズムです。 ;ディスクに一度に書き込めるのは1つのファイルだけ! ;これで十分です。このルーチンが呼び出されるたびにディスクのファイル数が変更されます。 ;書き込まれたファイルの後にディスクが論理的に終了するようにします。 ;論理:
;‐ (WriteFile が呼び出された) かつ (A <> ‐1) の場合、DiskFileCount := A ;‐ ディスクは最後まで進み、
ディスクファイル数
;‐ RETaddr+2 で指定されたデータをディスクの末尾に書き込みます ;‐ DiskFileCount が増加しました
;‐ データが読み戻され、書き込まれたデータと比較されます
;‐ エラーが発生した場合(比較が失敗するなど)、
DiskFileCount が減少しました
DiskFileCount はディスク上に実際に記録されたファイル数であることに注意してください。
;ハードコードされたパラメータを読み込む
AppendFile: LDA #$ff;現在の DiskFileCount を使用
ファイルの書き込み:
STA $0E; Aのファイル数を指定

 Machine Translated by Google
230億ドル LDA #$ff
$E23D JSR GetHCPwWPchk;エラー時に[$0E]でYをロードします $E240 LDA $0101
$E243
PHA
;ディスクの末尾にデータを書き込む $E244 LDA #$03;2 回の試行 $E246 STA $05
$E248 12月 $05
$E24A BEQ $E265
JSR 最終ファイル書き込み $E24F BNE $E248
;ディスクの最後にあるデータを検証する $E251 LDA #$02
$E253 STA $05
$E24C
JSR 最終ファイルチェック $E258 BEQ $E265
$E25A 12月 $05 $E25C BNE $E255
; リードバック中にエラーが発生した場合、最後のファイルを非表示にします $E25E STX $05; 保存エラー #
$E255
JSR ファイル数の設定 $E263 LDX $05; 復元エラー #
$E260
;戻る
$E265
$E266 STA $0101
$E269 $E26A
TXA RTS
人民解放軍
最終ファイルの書き込み: $E26E LDA $0E
$E270 CMP #$ff
$E272 BNE $E288 $E274 JSR Get#ofFiles
$E277 JSR スキップファイル; $E27A LDA #$03
$E27C JSR 書き込みブロックタイプ $E27F LDA #$00
$E281 JSR SaveData; 最後のファイルを書き出す
$E284
$E287
$E288 STA $06
JSR 転送完了
RTS
JSR チェックディスクヘッダー
ディスクの最後まで進む

 Machine Translated by Google
$E28A JSR ファイルセット $E28D JMP $E277
最終ファイルのチェック: JSR チェックディスクヘッダー
$E293 LDX $06; 現在のファイル数をロード
$E295
$E296
インクス TXA
$E297 JSR Set#ofFiles;現在のファイル数を増やす
$E29A JSR スキップファイル; 最後のファイルにスキップ
$E29D LDA #$03
$E29F JSR チェックブロックタイプ
$E2A2 LDA #$ff
$E2A4 JSR SaveData; 最後のファイルを検証する
$E2A7 $E2AA
JSR 転送完了 RTS
;[$06]でファイル数を設定します SetFileCnt: JSR ChkDiskHdr
$E2AE LDA $06
$E2B0 JSR ファイルセット
$E2B3 $E2B6
JSR 転送完了 RTS
; ロイヤリティフリー ... ろろろろ
;ファイル数を調整します ;
; ロイヤリティフリー ... ろろろろ
;ディスクの元のファイル数を読み取り、そこからA値を減算して ;差分を新しいファイル数としてディスクに書き込みます。ヘッダーを使用します
比較する
;文字列。A が元のディスク ファイル数より大きい場合、エラー 31 が返されます。
;このルーチンには2つのエントリポイントがあります。1つは現在のファイル数を調整するものです ;A経由で、そして単純にファイル数をAの値に設定するもの。

 Machine Translated by Google
;ルーチンはどのエントリポイントが呼び出されてもディスク読み取りサイクルを実行します。
;ディスク ファイル数を A に設定するには、SetFileCnt0/1 を使用する方が適切です。
SetFileCnt2: LDX #$ff;A値を使用する $E2B9 BNE $E2BD
AdjFileCnt: LDX #$00;FileCnt‐A を使用 $E2BD STX $09
JSR 取得HCPwWPchk $E2C2 LDA $0101
PHA
;ディスクファイル数を取得
$E2BF $E2C5
$E2C6 $E2C8 $E2CA $E2CC $E2CE $E2D1
;差を計算する $E2D3 $E2D5 $E2D6 $E2D8 $E2DA $E2DC $E2DE
$E2E0 カウ ント
$E2E2
LDA #$03;2 回の試行 STA $05
12月 $05
BEQ $E2F1
JSR ファイル数取得 BNE $E2CA
LDA $06; ロードファイル数 SEC
SBC $02; 差額を計算
LDX $09
BEQ $E2DE
LDA $02; 元のアキュムレータ値を使用する LDX #$31;
BCC $E2F1;
STA $06
Aが現在のファイルより小さい場合は分岐する
;ディスクファイル数を設定する $E2E4 LDA #$02;2 回の試行 $E2E6 STA $05
JSR ファイル数の設定 $E2EB BEQ $E2F1
$E2ED 12月 $05 $E2EF BNE $E2E8
$E2E8
$E2F1
$E2F2 STA $0101
$E2F5
人民解放軍
TXA

 Machine Translated by Google
$E2F6
RTS
;ファイル数を[$06]に保存します GetFileCnt: JSR ChkDiskHdr
$E2FA JSR Get#ofFiles
$E2FD 300ユーロ
JSR 転送完了 RTS
; ロイヤリティフリー ... ろろろろ
;ディスクファイル数を設定す る ;set disk file count ;set ...
; ロイヤリティフリー ... ろろろろ
;このルーチンはディスクのファイルカウント(ブロック2に格納されている)のみを書き換えます。
;A)では、これ以降は他のファイルは読み書きされません。ヘッダー比較を使用します。 ;弦。
SetFileCnt1: LDX #$01;A の値に 1 を加算 $E303 BNE $E307
SetFileCnt0: LDX #$00;通常のエントリ ポイント
$E307 $E309 $E30C $E30F $E310 $E311
$E313 $E315 $E317 $E319 310億ユーロ $E31E $320 円 $E322 $E324 $E325 $E328
STX $07
JSR 取得HCPwWPchk
LDA $0101
PHA
CLC
LDA $02; 初期A値パラメータ)
ADC $07
STA $06
LDA #$02;2 回の試行
STA $05
JSR ファイル数の設定
BEQ $E324
12月 $05
BNE 310億ユーロ 人民解放軍
STA $0101 TXA
(またはHCの3番目のバイト

 Machine Translated by Google
$E329
RTS
; ロイヤリティフリー ... ろろろろ
;ディスク情報を取
得する ;ディスク情報を取得する ;ディスク情報を取得する
; ロイヤリティフリー ... ろろろろ
;この手順はディスク全体を読み取り、次のような情報のみを返します。
;ディスクサイズ、ファイル名など
;パラメータ
;‐‐‐‐‐‐
;RETaddr 収集する情報の宛先アドレスへのポインタ
;情報フォーマット ;‐‐‐‐‐‐‐‐‐‐‐‐
;0 1 メーカーコード
;1 4 ゲーム名文字列
;5 1 ゲームバージョン ;61ディスク面#
ディスク1枚#1 ;81ディスク#2
;91ディスク#3
;A 1 ディスク上のファイル数
; (次のブロックはディスク上のファイルと同じ数だけ表示されます) ; バイトは示す)
;B 1 ファイルIDコード ;C 8 ファイル名 (ASCII)
; (以下は最後のファイルの後に存在する)
;x 1 ディスクサイズ上位バイト ;x+1 1 ディスクサイズ下位バイト
;7
;A にエラー # (ある場合) を返します。
情報ブロック)

 Machine Translated by Google
ディスク情報を取得: LDA #$00
$E32C JSR GetHCPwNWPchk; 16ビットポインタを1つ取得; [$02]にAを格納
$E32F LDA $0101
PHA $E333 LDA #$02
$E335 STA $05 $E337 JSR $E346 $E33A BEQ $E340; $E33C 12月 $05 $E33E BNE $E337
$E332
$340 円
$E341 STA $0101
$E344 $E345
TXA RTS
人民解放軍
;ディスク読み取りプロセスを起動
$E346 先頭のFDS文J字S列R をSt検ar証tXfer; ディスク
$E349 LDA $00 340億ドル STA $0A $E34D LDA $01 $E34F STA 00億ドル $E351 LDY #$00 $E353 スタイル$02 $E355 スタイル$03
;次の10バイトをディスクからRAMのPtr($0A)にロードします $E357 JSR 転送バイト
$E35A STA ($0A),Y
インド $E35D CPY #$0a
$E35F BNE $E357
$E361 JSR AddYtoPtr0A;Word($0A)に10を加算
;このファイルの残りのデータ(31バイト)を破棄します $E364 LDY #$1f
$E366 JSR 転送バイト
$E35C
デイ $E36A BNE $E366
$E369
;ファイル数を取得
$E36C
$E36F JSR Get#ofFiles;[$06]に保存します
JSR ブロック読み取り終了
エラーがなければエスケープ

 Machine Translated by Google
$E372 LDY #$00
$E374 LDA $06
$E376 STA ($0A),Y; ([$0A]) にファイル数を保存する $E378 BEQ $E3CB; ファイル数 = 0 の場合に分岐
;次のファイルの情報を取得
$E37A $E37C $E37F $E382 $385 円 $E387
LDA #$03
JSR チェックブロックタイプ
JSR XferByte; ファイルシーケンスを破棄 # JSR XferByte; ファイル ID コード LDY#$01
STA ($0A),Y; ファイルIDコードを保存する
;ファイル名の文字列(8文字)を保存します
$E389 $E38A $E38D $E38F $E391
$E393 $E396 $399 円
インド
JSR 転送バイト STA ($0A),Y CPY #$09
BNE $E389
JSR AddYtoPtr0A; 16 ビット宛先ポインタを進める JSR XferByte; 低い値を捨てる
JSR XferByte; 負荷の高いアドレスを破棄する
ロードアドレス
;単語($02) += $105 + ファイルサイズ
$E39C $E39D $E39F $E3A1 $E3A3 $E3A5 $E3A7 $E3A9 $E3AC $E3AE $E3B1 $E3B3 $E3B4 $E3B6 $E3B8 $E3BA $E3BC $E3BE $E3C0 $E3C2
CLC
LDA #$05
ADC $02
STA $02
LDA #$01
ADC $03
STA $03
JSR XferByte; 低い FileSize を取得する STA $0C
JSR XferByte; 高い FileSize を取得する STA $0D
CLC
LDA $0C
ADC $02
STA $02
LDA $0D
ADC $03
STA $03
LDA #$ff
STA $09

 Machine Translated by Google
$E3C4 JSR RdData; ディスクからダミー読み取りデータ $E3C7 DEC $06; ファイル数を減らす #
$E3C9 BNE $E37A
;ディスクサイズを保存する
$E3CB LDA $03
$E3CD LDY #$01;RdData からの修正 $E3CF STA ($0A),Y
$E3D1 LDA $02
インド $E3D4 STA ($0A),Y
$E3D3
$E3D6 $E3D9
JSR 転送完了 RTS
;Word(0A)にYを追加します AddYtoPtr0A: ありがとう
CLC $E3DC ADC $0A $E3DE STA $0A
$E3E0 LDA #$00 $E3E2 ADC 00億ドル $E3E4 STA 00億ドル
$E3DB
$E3E6
RTS
; ロイヤリティフリー ... ろろろろ
;ハード コードされる
ろろろろろ
; ロイヤリティフリー ... ろろろろ
ポインター コンテンツ ...
このルーチンは3つのことを行います。まず、1つまたは2つのハードコードされた16ビットの ;2番目の戻りアドレスに続くポインタ。次に、 ;ディスクセットやディスクの書き込み禁止状態もチェックし、チェックが失敗した場合は、 ;スタック上の最初の戻りアドレスは破棄され、プログラム制御は ;2番目の戻りアドレスに返されます。最後に、位置を保存します

 Machine Translated by Google
;スタックを解放して、エラーが発生したときにプログラム制御が
;同じ場所。
;パラメータ
;‐‐‐‐‐‐
;2番目のコールアドレス 1 個または 2 個の 16 ビット ポインタ
;A ‐1 2 16ビットポインタが存在する
; その他の値 1 16ビットポインタが存在する
;rtns (エラーなし) ;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
;PC 元の呼び出しアドレス
;あ00
;[$00] パラメータがロードされた場所(‐1でない場合は [$02] にAが配置されます)
;(エラー)
;‐‐‐‐‐‐‐
;PC 2番目の呼び出しアドレス
;Yバイトは[$0E]に格納されます
;ディスクが設定されていない場合は01
; 03 ディスクが書き込み禁止の場合
;エントリポイント 取得HCPwNWPchk:
SEC; 書き込み保護チェックを行わない GetHCPwWPchk: CLC; 書き込み保護のチェック
;2番目の戻りアドレスをPtr($05)にロードします
$E3E8 BCS $E3EB
TSX デックス
$E3EB
$E3EC
$E3ED STX $04; スタックポインター1を[$04]に格納する
PHP の $E3F0 STA $02
$E3F2 LDY $0104,X $E3F5 スタイル$05
$E3EF

 Machine Translated by Google
$E3F7 LDY $0105,X $E3FA スタイル$06
;最初の16ビットパラメータをPtr($00)にロードします
税 $E3FD LDY#$01
$E3FF LDA ($05)、Y $E401 STA $00
$E3FC
$E403
$E404 LDA ($05)、Y $E406 STA $01 $E408 LDA #$02
;Aが元々‐1だった場合、2番目の16ビットパラメータをPtr($02)にロードします
$E40A CPX #$ff $E40C BNE $E41A
$E40E
$E40F LDA ($05)、Y $E411 STA $02
$E41C
インド
インド
$E413
$E414 LDA ($05)、Y $E416 STA $03 $E418 LDA #$04
;2番目の戻りアドレスを適切に増加します $E41A LDX $04
インド
CLC $E41D ADC $05
$E41F STA $0104,X $E422 LDA #$00 $E424 ADC $06 $E426 STA $0105,X
;ディスクセットステータスフラグをテストする
PLP
;書き込み禁止状態をテストする
$E435 LDX #$03;書き込み禁止エラー $E437 LDA $4032
$E429
$E42A LDX #$01;ディスク セット エラー
$E42C LDA $4032
$E42F そして #$01
$E431 BNE $E43E
$E433 BCS $E444; 書き込み保護チェックをスキップ

 Machine Translated by Google
$E43A そして #$04 $E43C BEQ $E444
;テストが失敗した場合は戻りアドレスを破棄する
$E43E $E43F $440 円 $E442 $E443 $E444
人民解放軍
人民解放軍
LDY $0E TXA コマンドライン RTS
; ロイヤリティフリー ... ろろろろ
;ディスク ヘッダー チェ ック ...
; ロイヤリティフリー ... ろろろろ
;ルーチンは、FDSの後に続くディスク上の最初の10バイトを比較するだけです ;文字列をPtr($00)が指す10バイトにコピーします。
;byte の場合、比較文字列内の同等の場所に ‐1 を配置できます。 ;そうでない場合、比較が失敗すると、適切なエラーが生成されます。
ChkDiskHdr: JSR $E448
$E44A
$E44C
$E453 BEQ $E464
$E455 LDX $08
$E457 CPX #$0a
$E459 BNE $E45D
450億ユーロ LDX #$10
$E45D LDA ($00),Y
$E45F CMP #$ff
$E461 JSR 転送失敗オンNEQ
$E464
StartXfer; FDS文字列を確認する LDX #$04
STX $08
LDY #$00
JSR 転送バイト
CMP ($00),Y; コードと格納されているバイトを比較します [ポイント($00)+Y]
$E44E $E451
インド

 Machine Translated by Google
$E465 CPY #$01
$E467 BEQ $E46D
$E469 CPY #$05
460億ドル BCC $E46F
$E46D INC $08
$E46F CPY #$0a
$E471 BNE $E44E
$E473 JSR XferByte; ブート読み取りファイルコード $E476 STA $08
$E478 LDY #$1e;30 回の反復
$E47A JSR XferByte; ブロックの最後までダミー読み取り
JSR ブロック読み取り終了 RTS
$E47D
$E47E BNE $E47A
$480 円 $E483
デイ
; ロイヤリティフリー ... ろろろろ
;ファイルカウントブロックルーチン rot ...
; ロイヤリティフリー ... ろろろろ
;これらのルーチンは、ファイルカウントブロックの読み取りと書き込みを具体的に処理します。
;FDS ディスクに保存されます。
;ブロックタイプ#2に記録されたファイル数を[$06]にロードします 取得ファイル数: LDA #$02
$E486 JSR チェックブロックタイプ
$E489 JSR 転送バイト
$E48C STA $06
$E48E $E491
JSR ブロック読み取り終了 RTS
;ディスクに記録するファイル数を(A 経由で)書き込みます。 ファイルセット数: PHA
$E493 LDA #$02
$E495 JSR 書き込みブロックタイプ
$E498 プラバ
$E499 JSR XferByte; ディスクファイル数を書き出す
$E49C
JSR ブロック書き込み終了

 Machine Translated by Google
$E49F
RTS
; ロイヤリティフリー ... ろろろろ
;ファイル一致テスト コ ンテンツ ...
; ロイヤリティフリー ... ろろろろ
;このルーチンはPtr($02)が指すバイト文字列を使用してディスクに通知します ;どのファイルをロードするかをシステムに知らせます。ファイルIDの番号は ;文字列。完全一致が見つかった場合、[$09] は 0 になり、[$0E] が増分されます。 ;20バイト後に一致するものが見つからない場合、または‐1エントリに遭遇した場合、[$09] ;は‐1に設定されます。文字列の最初のバイトが‐1の場合、BootID番号は ;ファイルのマッチングに使用(BootID以下のFileID)
;一致として認められます。 ;論理:
;if String[0] = ; FileID <= BootID の場合
; [$09]:=$00
; インク([$0E])
‐1の場合
;それ以外
; 私:=0
; while (String[I]<>FileID) または (String[I]<>‐1) の場合、Inc(I) を実行します。
または(I<20)
; 文字列[I] [$09]:=$00の場合 ;
; インク([$0E])
;それ以外
; [$09]:=$FF;
= ファイルIDの場合
ファイルマッチテスト:
JSR XferByte; ファイルシーケンス #

 Machine Translated by Google
$E4A3 JSR XferByte; ファイル ID # (X にロードされます)
$E4A6 LDA #$08;次の 8 バイトをスキップするように IRQ モードを設定します $E4A8 STA $0101
$E4AB
$E4AC LDY #$00
$E4AE LDA ($02)、Y
$E4B0 CMP #$ff;Ptr($02) = ‐1の場合、ブートIDコードをテストします $E4B2 BEQ $E4C8
$E4B4 TXA; ファイルID #
$E4B5 CMP ($02),Y
$E4B7 BEQ $E4CE
$E4B9
$E4CE LDA #$00 $E4D0 INC $0E $E4D2 STA $09 $E4D4 LDA $0101 $E4D7 BNE $E4D4;
8バイトすべてが読み込まれるまで待つ
$E4D9
RTS
コマンドライン
インド $E4BA CPY #$14
$E4BC BEQ $E4C4 $E4BE LDA ($02)、Y $E4C0 CMP #$ff $E4C2 BNE $E4B4
$E4C4 LDA #$ff
$E4C6 BNE $E4D2
$E4C8 CPX $08; ブート読み取りファイルコードを現在のコードと比較 $E4CA BEQ $E4CE
$E4CC BCS $E4D2; 可能)
; ロイヤリティフリー ... ろろろろ
;ファイル
をスキップします ロイヤリティフリー ...
; ロイヤリティフリー ... ろろろろ
;このルーチンは[$06]に格納されている値を使用して、 ;現在のファイル位置からダミー読み取り(スキップ)します。
決定する
上記の場合は分岐
(または等しいが、

 Machine Translated by Google
スキップファイル: LDA $06 $E4DC STA $08
$E4DE BEQ $E4F8; $E4E0 LDA #$03
ファイル数 = 0 の場合に分岐
$E4E2 JSR チェックブロックタイプ $E4E5 LDY #$0a;10バイトスキップ $E4E7 JSR 転送バイト
デイ
$E4EB BNE $E4E7
$E4ED LDA #$ff
$E4EF STA $09
$E4F1 JSR LoadData; ダミー読み取りファイルデータ $E4F4 12月 $08
$E4F6 BNE $E4E0
$E4EA
$E4F8
RTS
; ロイヤリティフリー ... ろろろろ
;ファイルをディスクからメモリにロードします。
; ロイヤリティフリー ... ろろろろ
;現在のファイルからディスク上の指定された宛先アドレスにデータをロードします
;ディスクに保存されているファイルのヘッダー情報によって。
;パラメータ
;‐‐‐‐‐‐
;[$09]: ダミー読み取り専用(ゼロでない場合)
ロードデータ:LDY #$00
$E4FB JSR 転送 1 バイト目 $E4FE STA $000A,Y
インド $E502 CPY #$04
$E501
$E504 BNE $E4FB
;ポインタ($0A): ;ポインタ($0C):
宛先住所 バイト転送数
RdData: JSR DecPtr0C

 Machine Translated by Google
$E509 JSR XferByte; ファイルの種類を取得する
PHA
$E50C
$E50D
$E510 LDA #$04
$E512 JSR チェックブロックタイプ $E515 LD$09
ゼロでない場合はVRAMにコピーする
$E517
人民解放軍 $E518 BNE $E549;
CLC 510億ドル LDA $0A $E51D ADC $0C
$E51F LDA 00億ドル $E521 ADC $0D $E523 BCS $E531;
$E51A
JSR ブロック読み取り終了
(DestAddr+XferCnt)<10000h の場合に分岐 ;DestAddr < 0200h の場合はダミーコピーを実行します
$E525 $E527 $E529 520億ドル $E52D $E52F $E531
$E533 $E536 $E538 $E53A $E53C $E53E $540 円 $E542 $E545 $E547
LDA 00億ドル CMP #$20 BCS $E533; そして #$07 CMP #$02 BCS $E533; LDY #$ff
JSR 転送バイト CPY #$00
BNE $E542 STA ($0A),Y INC $0A
BNE $E542 INC $0B
JSR DecPtr0C
BCS $E533 BCC $E572
DestAddr >= 2000h の場合に分岐
DestAddr >= 0200h の場合に分岐
;VRAMデータのコピー
$E549 CPY #$00 540億ドル BNE $E563 $E54D LDA $FE $E54F そして #$e7 $E551 STA $FE $E553 STA $2001; $E556 LDA 2002ドル; $E559 LDA 00億ドル
[NES] PPU セットアップ #2 [NES] PPUステータス

 Machine Translated by Google
550億ドル $E55E $560 円
$E563 $E566 $E568 $E56A $E56D $570 円
$E572 $E574 $E576 $E579 $E57A $E57D $580 円
STA $2006; LDA $0A STA $2006;
JSR 転送バイト CPY #$00
BNE $E56D STA $2007; JSR DecPtr0C BCS $E563
LDA $09
BNE $E57A
JSR ブロック読み取り終了 RTS
JSR 転送バイト
JSR転送バイト
JMP チェックディスクセット
[NES] VRAMアドレス選択 [NES] VRAMアドレス選択
[NES] VRAMデータ
; ロイヤリティフリー ... ろろろろ
;サイズとソースアドレスのオペランドを$0A..$0Dにロードします。
; ロイヤリティフリー ... ろろろろ
;このルーチンは、ディスク上のファイルデータの書き込み/検証時にのみ使用されます。 ;Ptr($02)のデータ文字列を使用してサイズとソースアドレスのオペランドをロードします ;それぞれPtr($0C)とPtr($0A)に格納されます。また、ソースコードが ;アドレスはビデオメモリからのものであり、その場合はレジスタをプログラムします。
;ファイルのサイズを文字列オフセット $0B 経由で Word($0C) に読み込みます ロードサイズとソース: LDY #$0b
$E585 LDA ($02),Y; ファイルサイズ LO
$E587 STA $0C
PPUアドレス
$E589
インド
$E58A LDA ($02),Y; ファイルサイズ HI $E58C STA $0D

 Machine Translated by Google
;文字列オフセット$0Eを介してソースアドレスをPtr($0A)にロードします。
$E58E $590 円 $E592 $E594 $E595 $E597
LDY #$0e
LDA ($02),Y; 送信元アドレス LO STA $0A
インド
LDA ($02),Y; 送信元アドレス HI STA 00億ドル
;ソース タイプ バイトをロードします (0 以外の場合は PPU メモリを使用することを意味します)
$599 円
$E59A LDA ($02)、Y $E59C BEQ $E5B1
;ソースアドレスでPPUアドレスレジスタをプログラムする $E59E JSR ディスパッチOBJ
(0..n‐1) $E5B4
RTS
; ロイヤリティフリー ... ろろろろ
インド
$E5A1 LDA $2002; $E5A4 LDA $0B $E5A6 STA $2006; $E5A9 LDA $0A
$E5AB STA $2006; $E5AE LDA $2007; $E5B1 JSR DecPtr0C; 範囲の転送カウン トを調整
リセットフリップフロップ 店舗HIアドレス
店舗LOアドレス 最初に読んだものを破棄する
;メモリ内のデータをディスク上のファイルに保存します。
; ロイヤリティフリー ... ろろろろ
;このルーチンはファイルデータの処理を含む2つのことを行います。 ;Aが0に設定されている場合、ファイルデータはメモリからディスクに書き込まれます。 ;A <> 0、ディスク上のファイル データが検証されます (メモリ内のデータと比較)。
ポルト($02)
;以下に説明する 17 バイトの構造体のアドレスが含まれます。 注意:

 Machine Translated by Google
;ディスク転送方向ビット($4025.2)はAと同期して設定する必要があります。
;routine はそれを自動的に変更しません。
;00 1 ;01 8;092
;0B 2 ;0D 1 ;0E 2 ;10 1 ;11
ID
名前 ロードアドレス サイズ
タイプ (0 = CPU データ) ファイルデータのソースアドレス(ディスクに書き込まれていない) ソースアドレスタイプ (0 = CPU; ディスクに書き込まれない)
;構造体の最初の14バイトはファイルヘッダーとして直接使用されます ;データ。ファイルシーケンス#ファイルヘッダーの部分は別途指定されます ;([$06]内)。オフセット0E以降のデータはファイルヘッダーデータとして使用されません。
;構造体のオフセット0Eは、実際のメモリのアドレスを指定します。 ;ファイルデータが存在します。オフセット10はソースメモリタイプを指定します(0 = CPU; ;その他 = PPU)。
;エントリーポイント
SaveData:STA $09; Aの値は[$09]に保存されます
$E5B7 $E5B9 $E5BC $E5BE
$E5C0 $E5C2
$E5C4
$E5C7 LDY #$00
$E5C9 LDA ($02),Y; ヘッダーバイトをロード $E5CB JSR XferByte; 書き出す(または読み込む)
は
LDA $06; 現在のファイルをロード #
JSR XferByte; ファイルシーケンス番号を書き出す ([$06] から)
LDX $09
BEQ $E5C7; 書き込み [$09]はジャンプするように設定する必要があります
LDX #$26;エラー #
CMP $06; 記録されたシーケンス番号を正しいものにする
JSR 転送失敗オンNEQ
;ファイル ヘッダー ブロック全体を書き込み/チェックするループ (ファイル シーケンス # を除く)

 Machine Translated by Google
$E5CE LDX $09
$E5D0 デ BEQ $E5D9; ジャンプしてデータを書き込むかどうかをチェックする ィスク
$E5D2 LDX #$26;エラー #
$E5D4 CMP ($02),Y; 記録されたヘッダーバイトを本来あるべき値に置き換える
$E5D6 $E5D9 $E5DA チ ェック済み $E5DC
JSR 転送失敗オンNEQ
INY; ポインターの位置を進める
CPY #$0e;ループは14バイトが読み込まれたら終了する
BNE $E5C9
;次のブロックを読み取り用に設定 $E5DE LDX $09 $E5E0 BEQ $E616;
;ソースタイプを確認し、ステータスを読み取り/検証する
$E5ED LDY #$10
$E5EF LDA ($02),Y; データソースタイプビットをチェック
$E5F1 BNE $E624; 代わ CPUメモリマップにない場合は分岐する(PPU りに)
$E5F3 LDY #$00
$E5F5 LDX $09; 読み取りまたは書き込みをチェック
$E5F7 BEQ $E60A; 書き込みの場合は分岐
;ディスク上のデータをチェック
$E5F9 JSR 転送バイト $E5FC LDX #$26
$E5FE CMP ($0A),Y
600ドル JSR 転送失敗オンNEQ
代わりに書く場合は分岐する
$E5E2
$E5E5 JSR LoadSiz は Ptr($0A) と Ptr($0C) を設定します $E5E8 LDA #$04
$E5EA JSR チェックブロックタイプ
$E603
$E608 BCC $E638
;データをディスクに書き込む $E60A LDA ($0A)、Y $E60C JSR 転送バイト
JSR ブロック読み取り終了
JSR株式会社0Adec0C $E606 BCS $E5F9
JSR株式会社0Adec0C $E612 BCS $E60A
$E60F
$E614 BCC $E638

 Machine Translated by Google
;書き込み用の次のブロックをセットアップする
;VRAMでディスク上のデータを検証する
$E624 $E626 $E628 620億ドル $E62D $630 円 $E633 $E636
LDX $09
BEQ $E640
JSR 転送バイト
LDX #$26;エラー #
CMP $2007
JSR 転送失敗オンNEQ JSR DecPtr0C
BCS $E624
;ブロックの読み取り終了 $E638 LDX $09 $E63A BEQ $E649;
代わりに書く場合は分岐する
[NES] VRAMデータ
$E63C $E63F
JSR ブロック読み取り終了 RTS
JSR ブロック書き込み終了
$E616
$E619 JSR LoadSiz は Ptr($0A) と Ptr($0C) を設定します $E61C LDA #$04
$E61E JSR 書き込みブロックタイプ
$E621 ジャンプ$E5ED
;VRAMからディスクにデータを書き込む
$640 円 $E643 $E646
LDA $2007; JSR 転送バイト JMP $E633
;ブロック書き込み終了
$E649 $E64C
JSR ブロック書き込み終了 RTS
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
;ドライブの準備ができるまで待機します(つまり、ディスク ヘッドがディスクの先頭にある)。
WaitForRdy: JSR 停止モーター

 Machine Translated by Google
650ドル $E652 $E655 $E658 650億ユーロ $E65D $660 円 $E662 $E664 $E666 $E669 660億ドル $E66E $E66F $E672 $E675 $E678 $E67A $E67D $E67E $E681 $E682 $E684
LDY #$00
JSR MilSecTimer;0.256秒の遅延
JSR MilSecTimer;0.256秒の遅延 JSR スタートモーター
LDY #$96
JSR MilSecTimer;0.150秒の遅延
LDA $F9
ORA #$80;バッテリーチェックを有効にする スタ $F9
STA $4026
LDX #$02;バッテリーエラー
EOR 4033ドル
ロールA
JSR 転送失敗
JSRストップモーター JSR スタートモーター
LDX #$01;ディスク セット エラー LDA $4032
LSR A; チェックディスクセットビット JSR 転送失敗
LSR A; チェックレディビット
;ディスクドライブモーターを停止
停止モーター: $E687 $E689 680億ドル $E68E
LDA $FA そして #$08
オラ #$26 STA $4025 RTS
BCS $E678; RTS
ドライブの準備ができるまで待つ
;ファイルの最初のバイトがアキュムレータの値と等しいことを確認します
チェックブロックタイプ: LDY #$05 $E691 JSR MilSecTimer;0.005秒遅延 $E694 STA $07
$E696 CL
$E697
$E699
$E69A
$E69C
$E69E
$E6A0
$E6A3
$E6A6
ADC #$21;エラー # = 21h + 失敗したブロック タイプ (1..4) テイ
LDA $FA オラ#$40 STA $FA STA $4025
JSR 転送 1 バイト目 PHA

 Machine Translated by Google
$E6A7
$E6A8
$E6A9
$E6AA CMP$07
$E6AC JSR 転送失敗オンNEQ
$E6AF
RTS
;転送を開始します 開始Xfer:
ありがとう 税 人民解放軍
;ブロック開始マークとアキュムレータ内のバイトを書き出します 書き込みブロックタイプ: LDY #$0a
$E6B2 STA $07
$E6B4 LDA $FA
$E6B6 AND #$2b;転送方向を書き込みに設定
$E6B8 STA $4025
$E6BB JSR MilSecTimer;0.010秒遅延
$E6BE LDY #$00
$E6C0 STY $4024; $E6C3 ORA
#$40;FDS にデータを今すぐディスクに書き込むように指示します $E6C5 スタ $FA
$E6C7 STA $4025
$E6CA LDA #$80
$E6CC JSR Xfer1stByte;ブロック開始マークを書き出す
$E6CF LDA $07
$E6D1 JSR XferByte; ブロックタイプを書き出す
$E6D4 RTS
;FDS文字列
FDSstr DB '*CVH‐ODNETNIN*'
JSR 待機待ち $E6E6 LDY #$c5
$E6E8 JSR MilSecTimer;0.197秒の遅延 $E6EB LDY #$46
$E6ED JSR MilSecTimer;0.070秒の遅延 $E6F0 LDA #$01
$E6F2 JSR チェックブロックタイプ
$E6F5 LDY #$0d
$E6F7 JSR 転送バイト
$E6FA LDX #$21;FDS 文字列の比較に失敗した場合、エラー 21h $E6FC CMP FDSstr、Y
$E6FF JSR 転送失敗オンNEQ
RTS
$E702
$E703 BPL $E6F7
$E705
デイ
書き込みレジスタをゼロにする

 Machine Translated by Google
;ブロックの最後にあるCRC OKビットをチェックします EndOfBlkRead: JSR XferByte; 最初の CRC バイト
$E709 700億ユーロ $E70E $E710 $E712 $E714 $E716 $E718 710億ドル $E71E $720 円 $E723 $E725 $E727
LDX #$28;ファイル終了エラー #
LDA $4030
そして「ディスクの終わり」ステータスをチェックする BNE 転送失敗
LDA $FA
ORA #$10;ブロック終了マーク (CRC) の処理中に設定されました STA $FA
STA $4025
JSR XferByte; 2 番目の CRC バイト
LDX #$27;CRC 失敗エラー #
LDA $4030
AND #$10;CRCビットをテスト
BNE 転送失敗
BEQ チェックディスクセット
;書き込まれるブロックにCRC値を書き出す処理を行います
ブロック書き込み終了:
JSR 転送バイト
$E72C $E72E $E731 $E733 $E735 $E737 $E739 730億ドル $E73E た っぷり $740 円 $E741 $E743 $E745 $E748 $E74A
LDX #$29 LDA $4030
そして #$40 BNE 転送失敗
LDA $FA
ORA #$10; により、FDS は CRC を直ちに書き出します
STA $FA; 保留中のバイト書き込みの完了後
STA $4025
LDX #$b2;0.0005秒の遅延(アダプタを許可するため)
DEX; CRC 全体を書き出すのにかかる時間) BNE $E740
LDX #$30
LDA $4032
そして #$02 BNE 転送失敗
;ディスク転送の割り込みを無効にし、ディスクセットの状態をチェックします チェックディスクセット: LDA $FA
$E74E $750 円 $E752 $E754 $E757 $E759 $E75C
そして #$2f
オラ #$04
STA $FA
STA $4025
LDX #$01;ディスク セット エラー # LDA $4032
LSR A

 Machine Translated by Google
$E75D JSR 転送失敗
$760 円
RTS
;ブロックの終わりのCRC値をPtr($0A)+Yに読み込みます。
;サブルーチンは他のディスクルーチンでは使用されません。 ReadCRC: JSR XferByte
$E764 $E766 $E768 $E76B $E76D $E76F $E770 $E773 $E775
STA ($0A),Y LDX #$28 LDA $4030 そして #$40 BNE 転送失敗 インド
JSR 転送バイト
STA ($0A),Y
JMP チェックディスクセット
;転送を終了するときにディスパッチされます。A でエラー # を返します。
XferDone:LDX #$00;エラーなし $E77A BEQ $E786 XferFailOnCy: BCS XferFail
RTS 送失敗オンNEQ: 転送失敗:TXA
$E77E 転
$E782 $E784 $E785 $E786 $E788 $E78A $E78C $E78E $E791 $E792 $E793
LDX $04
TXS; PCを元の発信者のアドレスに復元する 税
LDA $FA そして #$09 オラ#$26 STA $FA STA $4025 TXA
コマンドライン
RTS
;ディスクドライブとシステム間のデータ交換のためのメインインターフェース。 &
Xfer1stByte: LDX #$40
$E796 $799 円 790億ユーロ $E79C $E79E
STX $0101 ロール$FA SEC
ROR $FA LDX $FA
BEQ $E77E

 Machine Translated by Google
$E7A0 STX 4025ドル バイト転送:CLI
$E7A4 JMP $E7A4
;ゼロページ内の16ビットポインタを増分するルーチン inc0Adec0C: INC $0A
$E7AE LDA $0C $E7B0 SBC #$01 $E7B2 STA $0C $E7B4 LDA $0D $E7B6 SBC #$00 $E7B8 STA $0D
$E7A9
$E7AB INC $0B DecPtr0C:SEC
$E7BA
RTS
BNE デクPtr0C
; ロイヤリティフリー ... ろろろろ
;PPU データ プロ
セッサ ;PPU データ プロセッサ ;PPU データ プロセッサ
; ロイヤリティフリー ... ろろろろ
;このルーチンはバイトの文字列をカスタム命令として扱います。これらの文字列は ;通常のCPU命令と同様の方法で保存され、 命令は順番に格納•処理され、命令の長さは ;ダイナミック。指示は簡単に記入/コピーできるように設計されています ;PPUメモリマップ内のランダムな場所へのデータの転送。PPUへの完全なランダムアクセス ;メモリがサポートされており、サブルーチンを呼び出すことも可能です。すべてのデータ PPUメモリに書き込まれたデータは、実際の命令(最大64)に格納されます。
; 1 つの命令で連続したバイトのデータを保存できます。
;「JSR PPUdataPrsr」オペコードの後に続く16ビットの即値はポインタである

 Machine Translated by Google
;処理される最初の PPU データ文字列に追加します。
PPU データ プロセッサのオペコードは次のように配置されます。
;+‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
;|特殊なオペコード|
;+‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
; $4C: サブルーチンを呼び出します。16ビットの呼び出しアドレスが続きます。このオペコードは
; 'JMP $xxxx' 6502 ニーモニックに相当します。
; $60: サブルーチンを終了します。呼び出し後の命令に戻ります。
; このオペコードは、「RTS」6502 ニーモニックに相当します。
; $80..$FF: プログラムの終了。この命令コードが実行されるまで処理は停止しません。
;
遭遇しました。
;+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
;|データ移動/埋め込み命令フォーマット| ;+‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐+
;バイト0
; ‐‐‐‐‐‐
; 宛先PPUアドレスの上位バイト。$60、$4C、または
; $7F より大きい。
; バイト1
; ‐‐‐‐‐‐
; 宛先 PPU アドレスの下位バイト。
; バイト2ビットの説明
; ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐
; 7: PPU PPUアドレスを1/32(0/1)増加 ; 6: ; メモリにデータをコピー/埋め込む (0/1) 5‐0: バイト転送数 (0 は 64 バイトを示します)
; バイト 3..n ; ‐‐‐‐‐‐‐‐‐‐
‐ フィルビットが設定されている場合、ここには1バイトのみがあり、 価値は

 Machine Translated by Google
; 指定されたバイト転送カウントで PPU メモリを埋めます。
; ‐ 代わりにコピーモードが設定されている場合、このデータには コピーするバイト数
; PPUメモリに書き込む。ここで表示されるバイト数はバイト数と同じである。 ;転送回数。
;エントリーポイント PPUdataPrsr: JSR GetHCparam $E7BE JMP $E815
;[Param]はAにあります
$E7C1 PHA; 保存 [Param]
$E7C2 STA $2006;
インド
インド
;Bit(7,[Param+2]) の場合、PPUinc:=32、それ以外の場合は PPUinc:=1 $E7D0 LDA $FF
$E7D2 オラ#$04
$E7D4 BCS $E7D8
$E7C5
$E7C6 LDA ($00),Y; [Param+1]をロード
$E7C8 STA $2006; [NES] VRAMアドレス選択
$E7CB
$E7CC LDA ($00),Y; [Param+2]をロード
$E7CE ASL A; キャリーのビット7
$E7CF PHA; [Param+2] を保存
もしそうなら ふーん
$E7D6 そして#$fb $E7D8 STA 2000ドル $E7DB スタ$FF
;Bit(6,[Param+2])の場合
$E7DD PLA; [Param+2]をロード
[NES] PPU セットアップ #1
ふーん
$E7DE
$E7DF PHP; ゼロステータスを保存
$E7E0 BCC $E7E5
$E7E2 オラ#$02
$E7E4 INY; フィルビットが設定されている場合は次のバイトに進む
;ゼロ([Param+2]かつ$3F)の場合、carry:=1、それ以外の場合はcarry:=0
$E7E5
$E7E6
$E7E7 BNE $E7EA
$E7E9
アメリカ手話
PLP
CLC SEC
[NES] VRAMアドレス選択

 Machine Translated by Google
$E7EA $E7EB $E7EC
ROR A LSR A 税
;I:=0からX‐1までの場合、[$2007]:=[Param+3+(XかつBit(6, [パラメータ+2]))]
$E7ED BCS $E7F0
$E7EF
$E7F0 LDA ($00),Y $E7F2 STA $2007;
$E7F5
デックス
$E7F6 BNE $E7ED
インド
;ゼロになっているように見えるので、これが何をするのかわかりません
;最後にPPUアドレスレジスタ全体
$E7F8 PLA; ロード [Param]
$E7F9 CMP #$3f
$E7FB BNE $E809 $E7FD STA $2006; 800ユーロ STX 2006ドル; $E803 STX 2006ドル; $E806 STX 2006ドル;
;Param を Y+1 増加
SEC
ありがとう
[NES] VRAMアドレス選択 [NES] VRAMアドレス選択 [NES] VRAMアドレス選択 [NES] VRAMアドレス選択
$E809
$E80A
800億ユーロ ADC $00 $E80D STA $00 $E80F LDA #$00 $E811 ADC $01 $E813 STA $01
;bit(7,[Param])が1の場合は終了
$E815 LDX 2002ドル;
$E818 LDY #$00
$E81A LDA ($00),Y; オペコードをロード $E81C BPL $E81F
$E81E
RTS
;RET命令のテスト
$E81F CMP #$60 $E821 BNE $E82D
;[パラメータ] = $60:
[NES] VRAMデータ
[NES] PPUステータス

 Machine Translated by Google
;スタックからパラメータをポップ
$E829 LDY #$02;増分額 820億ドル BNE $E809;
;JSR オペコードのテスト $E82D CMP #$4c $E82F BNE $E7C1
;[パラメータ] = $4C ;Paramをスタックにプッシュ
$E831 LDA $00
$E823
人民解放軍 $E824 STA $01
$E826
人民解放軍 $E827 STA $00
PHA $E834 LDA $01
$E833 $E836
PHA ;パラメータ = [パラメータ+1]
$E837 $E838 $E83A 830億ドル $E83C $E83E $840 円 $E842
インド
LDA ($00),Y 税
インド
LDA ($00),Y STA $01 00ドル
BCS $E815;
無条件
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
;2番目の戻りアドレスの後のハードコードされた16ビット値を[$00]と[$01]に取得します
;その後、戻りアドレスは 2 増加します。 GetHCパラメータ: TSX
$E845 LDA $0103,X
$E848 STA $05
無条件

 Machine Translated by Google
$E84A $E84D $E84F $E851 $E853 $E855 $E856 $E858 $E85A 850億ドル $E85D $E85F $E862 $E864 $E866 $E869
$E86A $E86C $E86E $E871 $E873 $E876 $E878 $E87A 870億ドル $E87E $E87F $E882 $885 円 $E886 $E889 $E88A $E88D $890 円 $E891 $E893 $E894 $E896 $898 円 890億ドル $E89E $E8A1 $E8A4
LDA $0104,X STA $06 LDY#$01 LDA ($05)、Y STA $00 インド
LDA ($05)、Y STA $01 CLC
LDA #$02
ADC $05
STA $0103,X
LDA #$00
ADC $06
STA $0104,X RTS
LDA $FF
そして #$fb
STA 2000ドル
スタ$FF
LDX 2002ドル;
LDY #$00
BEQ $E8A5 PHA
STA $2006; インド
LDA $0302,Y STA $2006; インド
LDX $0302,Y インド
LDA $0302,Y STA $2007; デックス
BNE $E889 人民解放軍
CMP #$3f BNE $E8A4 STA $2006; STX 2006ドル; STX 2006ドル;
STX 2006ドル; インド
[NES] PPU セットアップ #1 [NES] PPUステータス
[NES] VRAMアドレス選択
[NES] VRAMアドレス選択
[NES] VRAMデータ
[NES] VRAMアドレス選択 [NES] VRAMアドレス選択 [NES] VRAMアドレス選択 [NES] VRAMアドレス選択

 Machine Translated by Google
$E8A5 LDA $E8A8 BPL $E8AA STA $E8AD LDA $E8AF STA
$0302,Y $E87A $0302 #$00 $0301
2002ドル; $0300,X $2006;
$E8B2
RTS
$E8B3 LDA $E8B6 LDA $E8B9 STA
[NES] PPUステータス [NES] VRAMアドレス選択
[NES] VRAMアドレス選択
[NES] VRAMデータ [NES] VRAMデータ
$E8BC
$E8C0 STA $2006;
$E8CA STA $0300,X
インクス
$E8BD LDA $0300,X
$E8C3
インクス $E8C4 LDA $2007; $E8C7 LDA $2007;
$E8CD
$E8CE
$E8CF BNE $E8B6
$E8D1
$E8D2 STA $03
$E8D4 STX $02
$E8D6 スタイル$04
$E8D8 JSR 取得HCパラメータ $E8DB LDY #$ff
$E8DD LDA #$01
$E8DF BNE $E8F6
$E8E1 STA $03
$E8E3 STX $02
$E8E5 JSR 取得HCパラメータ $E8E8 LDY #$00
$E8EA LDA ($00),Y $E8EC そして #$0f $E8EE STA $04 $E8F0 LDA ($00),Y
$E8F2
$E8F3
$E8F4
$E8F5
$E8F6 STA $05 $E8F8 LDX $0301
インクス
デイ RTS
LSR A LSR A LSR A LSR A

 Machine Translated by Google
$E8FB $E8FD 900ユーロ $E903 $E905 $E908 900億ユーロ $E90D $E90F $E912 $E915 $E916 $E918 910億ユーロ $E91D $E91F $E922 $925 円 $E926 $E928 $E92A $E92C $E92E 930ドル $E932 $E934 $E936 $938 円 930億ユーロ
$E93C $E93D $940 円 $E942 $945 円 $947 円 $E94A 940億ドル $E94C $E94E
$E94F 950ドル
LDA $03 STA $0302,X JSR $E93C LDA $02 STA $0302,X JSR $E93C LDA $04 STA $06 STA $0302,X JSR $E93C インド
LDA ($00),Y STA $0302,X 12月 $06 BNE $E912 JSR $E93C STX $0301 CLC
LDA #$20 ADC $02 STA $02 LDA #$00 ADC $03 STA $03 12月 $05 BNE $E8FB LDA #$ff STA $0302,X RTS
インクス
CPX $0300
BCC $E94E
LDX $0301
LDA #$ff
STA $0302,X 人民解放軍
人民解放軍
LDA #$01 RTS
デックス デックス

 Machine Translated by Google
$E951 $E952 $953 円 $954 円 $E956 $E957 $959 円 $E95A 950億ユーロ $E95E 960ドル $E962 $E963 $966 円 $968 円 $E96A 960億ドル $E96E $E96F
$970 円 $972 円 $975 円 $976 円 $978 円 970億ドル $E97C
$E97D $E97F $981 円 $983 円 $984円 $986 円 $987円 $989 円 980億ドル $E98D $E98F 990ドル $991 円 $992 円 $994 円
デックス TXA
CLC
ADC #$03 デイ
BNE $E953 税
テイ
LDA $0300,X CMP$00 BNE $970E インクス
LDA $0300,X CMP$01 BNE $970E インクス
LDA $0300,X CLC
RTS
LDA $00
STA $0300,Y インド
LDA $01
STA $0300,Y SEC
RTS
LDA #$08 STA $00 LDA $02 アメリカ手話 ロール$00 アメリカ手話 ロール$00 そして #$e0 STA $01 LDA $03 LSR A
LSR A LSR A オラ$01 STA $01

 Machine Translated by Google
$996 円
$997 円 999ドル $E99A 990億ドル $E99C $E99E $E9A0 $E9A2 $E9A4 $E9A5 $E9A7 $E9A8 $E9AA $E9AC $E9AE $E9B0
RTS
LDA $01 アメリカ手話 アメリカ手話 アメリカ手話 STA $03 LDA $01 STA $02 LDA $00 LSR A
ROR $02 LSR A
ROR $02 LDA #$f8 そして$02 STA $02 RTS
; ロイヤリティフリー ... ろろろろ
;乱数ジェネレータ rt ...
; ロイヤリティフリー ... ろろろろ
;シフトレジスタとXORを使用して疑似乱数を生成します。
;アルゴリズム
;‐‐‐‐‐‐‐‐‐
;繰り上がり [X] [X+1] ;‐‐> ;C 765432*0
‐‐‐> ‐‐‐> 765432*0 76543210 ...
[X+n] ‐‐‐> ‐‐‐>
‐‐‐> ‐‐‐>
;ノート
;‐‐‐‐‐
;* これら 2 つのポイントは XOR され、結果は C に保存されます。
;‐ シフトが発生すると、Cは[X]のMSBにシフトされ、[X]のLSBは

 Machine Translated by Google
; [X+1]のMSBにシフトされ、以下同様に、さらに数が増えていく。
; です(使用するバイト数は Y で示されます)。
;‐ ここでは少なくとも2つの8ビットシフトレジスタを使用する必要がありますが、さらに使用すると
; 乱数生成には影響しません。また、16シフト後には、
; 最初の2バイトの16ビットの結果は次の2バイトと同じになるので、
; このアルゴリズムでは、実際に 2 バイト以上を使用する必要はありません。
;‐ この関数を連続して呼び出すたびに、新しい乱数が利用可能になります。
; サブルーチンですが、最初に良い乱数を得るためには、
; このルーチンを複数回呼び出す必要があります。
;‐ このルーチンを初めて呼び出すときは、最初の2バイトを確認してください
; 両方に 0 が含まれていてはいけません。そうでない場合、乱数アルゴリズムは機能しません。
;Yは 使用する8ビットレジスタ(通常2) ;Xはシフトする基数0pgアドレスです
;最初のビットサンプルを保存 ラウンド数: LDA $00,X
$E9B3 そして #$02 $E9B5 STA $00
;2番目のビットサンプルと1番目のビットサンプルの排他的論理和 $E9B7 LDA $01,X
$E9B9 そして #$02
$E9BB 終了 $00
;キャリーをXORの結果に設定
SEC
$E9BD
$E9BE BEQ $E9C1
$E9C0
CLC

 Machine Translated by Google
;Yバイト分の多倍精度シフト $E9C1 ROR $00,X
$E9C3
$E9C4
$E9C5 BNE $E9C1
$E9C7
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
$E9C8 LDA #$00 $E9CA STA $2003; $E9CD LDA #$02 $E9CF STA $4014;
$E9D2
RTS
$E9D3 00ドル $E9D5 12月 $00,X $E9D7 BPL $E9DE $E9D9 LDA #$09 $E9DB STA $00,X
$E9DD
$E9DE
$E9DF LDA $00,X $E9E1 BEQ $E9E5 $E9E3 12月 $00,X
$E9E5
$E9E8 BNE $E9DF
デックス $E9E6 CPX $00
$E9EA
RTS
; ロイヤリティフリー ... ろろろろ
;コントローラ読み取り関数
インクス
デイ RTS
ありがとう 税
[NES] SPR‐RAM アドレス選択 [NES] スプライトDMAトリガー

 Machine Translated by Google
;‐ ストロボコントローラー
;‐ [$F5] には [$4016] からのビット 0 の 8 回の読み取りが含まれています ;‐ [$00] には [$4016] からのビット 1 の 8 回の読み取りが含まれています ;‐ [$F6] には [$4017] からのビット 0 の 8 回の読み取りが含まれています ;‐ [$01] には [$4017] からのビット 1 の 8 回の読み取りが含まれています
読み取りCtrl: LDX $FB
$E9F1
$E9F2 STX 4016ドル; $E9F5 LDX #$08 $E9F7 LDA $4016;
$E9ED
インクス
$E9EE STX 4016ドル;
[NES] ポート #1 のジョイパッドと I/O ポート [NES] ポート #1 のジョイパッドと I/O ポート [NES] ポート #1 のジョイパッドと I/O ポート
[NES] ポート #2 のジョイパッドと I/O ポート
LSR A $E9FB ロール$F5
$E9FA
LSR A $E9FE ロール $00
$E9FD
$EA00 LDA $4017;
LSR A $EA04 ロール$F6
$EA03
LSR A $EA07 ロール$01
$EA06
$EA09 $EA0C
デックス $EA0A BNE $E9F7
RTS
; ロイヤリティフリー ... ろろろろ
;コントローラまたは関数
;[$F5]|=[$00] ;[$F6]|=[$01]
ORctrlrRead: LDA $00 $EA0F オラ$F5 $EA11 STA $F5 $EA13 LDA $01 $EA15 オラ$F6 $EA17 スタ$F6
$EA19
RTS
デックス

 Machine Translated by Google
; ロイヤリティフリー ... ろろろろ
;コントローラのステータスを取得
;‐ コントローラボタンの状態を[$F7] (CI)に返し、 [$F8] (CII)
;‐ 前回の更新以降に押された新しいボタンを返します
; [$F5] (CI) と [$F6] (CII)
GetCtrlrSts: JSR ReadCtrlrs
$EA1D BEQ $EA25; ゼロフ ReadCtrlrsは常に分岐するため ラグを設定する
$EA1F JSR ReadCtrlrs; この命令は使用されません
$EA22 JSR ORctrlrRead;この命令は使用されません
25ドル LDX #$01 $EA27 LDA $F5,X
テイ
RTS
; ロイヤリティフリー ... ろろろろ
$EA29
$EA2A EOR $F7,X $EA2C そして $F5,X $EA2E STA $F5,X 30ドル スタイル $F7,X
$EA32 35ドル
デックス $EA33 BPL $EA27
JSR 読み取りCtrl $EA39 LDY $F5
$EA36
$EA3B LDA
$F6
$EA3D
$EA3E
$EA41
$EA42 CMP $F6 $EA44 BNE $EA39 $EA46 CPY $F5 $EA48 BNE $EA39 $EA4A BEQ $EA25
$EA4C
$EA4F
$EA52 LDY $F5
PHA
JSR 読み取りCtrl 人民解放軍
JSR 読み取りCtrl
JSR ORctrlrRead

 Machine Translated by Google
$EA54 LDA $F6
$EA56
$EA57
$EA5A
$EA5D
$EA5E CMP $F6 $EA60 BNE $EA52 $EA62 CPY $F5 $EA64 BNE $EA52 $EA66 BEQ $EA25
PHA
JSR 読み取りCtrl JSR ORctrlrRead 人民解放軍
JSR 読み取りCtrl EA6Bドル LDA $00
$EA6D スタ $F7 $EA6F LDA $01 $EA71 スタ $F8 $EA73 LDX #$03 $EA75 LDA $F5,X
テイ
RTS
; ロイヤリティフリー ... ろろろろ
;VRAMフィルルー チン コンテンツ ...
; ロイヤリティフリー ... ろろろろ
;このルーチンは基本的に、VRAM 内の指定された場所を目的の値で埋めます。
;名前テーブルメモリに書き込むときに、別の値を指定して
;属性テーブル。パラメータは次のとおりです。
;A は HI VRAM アドレスです (LO VRAM アドレスは常に 0 です)
$EA68
$EA77
$EA78 EOR $F1,X $EA7A そして $F5,X $EA7C STA $F5,X $EA7E スタイル $F1,X
$EA80 $EA83
デックス $EA81 BPL $EA75

 Machine Translated by Google
;Xは塗りつぶし値 ;Yは反復回数(反復ごとに256バイト書き込まれる)。Aが20ドルの場合、または
; より大きい(名前テーブルVRAMを示す)、反復回数は常に4、
; このデータは属性の塗りつぶしデータに使用されます。
VRAMフィル:STA $00
$EA86 STX $01 $EA88 スタイル$02
;2006年の逆転をリセット $EA8A LDA 2002ドル;
;PPUアドレスの増分を1に設定 $EA8D LDA $FF $EA8F そして #$fb $EA91 STA 2000ドル $EA94 スタ $FF
;PPUアドレスHI:=[$00] ;PPUアドレスLO:=$00
$EA96 LDA $00 $EA98 STA $2006; EA90億ドル LDY #$00 $EA9D STY $2006;
[NES] PPUステータス
[NES] PPU セットアップ #1
[NES] VRAMアドレス選択
[NES] VRAMアドレス選択
; PPUaddr<$2000 の場合、X:=[$02]、それ以外の場合は X:=4
$EAA0 LDX #$04
$EAA2 CMP #$20
$EAA4 BCS $EAA8; 20ドル以上の場合は分岐 $EAA6 LDX $02
;i:=X が 1 になるまで Fill([$2007],A,256) を実行します $EAA8 LDY #$00
$EAAA LDA $01
$EAAC STA $2007;
デイ
$EAB0 BNE $EAAC
;次のループのためにYを設定 $EAB5 LDY$02
$EAAF
$EAB2
デックス $EAB3 BNE $EAAC
[NES] VRAMデータ

 Machine Translated by Google
;PPUaddr>=$2000の場合 $EAB7 LDA $00 $EAB9 CMP #$20 $EABB BCC $EACF;
; PPUaddrHI:=[$00]+3 ; PPUaddrLO:=$C0
$EABD ADC #$02 $EABF STA $2006; $EAC2 LDA #$c0 $EAC4 STA $2006;
20ドル未満の場合は支店
[NES] VRAMアドレス選択
[NES] VRAMアドレス選択
; I:=1 から $40 まで [$2007]:=[$02] を実行します $EAC7 LDX #$40
$EAC9 STY $2007;
;Xを復元
$EACF LDX $01
[NES] VRAMデータ
$EACC
デックス $EACD BNE $EAC9
$EAD1
RTS
; ロイヤリティフリー ... ろろろろ
;CPU メモリ フィル ルーチン コ ンテンツ ...
; ロイヤリティフリー ... ろろろろ
;このルーチンは、CPUマップメモリを指定された値で埋めるだけです。 ;はページです(256 バイト)。パラメータは次のとおりです。
;Aは塗りつぶし値 ;Xは最初のページです# ;Yは最後のページです#
メモリフィル: PHA
TXA
$EAD4 スタイル$01
$EAD3
CLC $EAD7 SBC $01
$EAD6

 Machine Translated by Google
$EAD9
$EADA
$EADB LDY #$00 $EADD スタイル $00 $EADF STA ($00),Y
デイ
$EAE2 BNE $EADF
$EAE1
$EAE4 12月 $01
$EAE6 $EAE9
インクス $EAE7 BNE $EADF
RTS
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
;メモリからPPUレジスタ0と5を復元 RstPPU05:LDA $2002;
スクロールレジスタフリップフロップをリセットする [NES] PPUスクロール
[NES] PPUスクロール
[NES] PPU セットアップ #1
$EAED LDA $EAEF STA $EAF2 LDA $EAF4 STA $EAF7 LDA $EAF9 STA
$EAFC
RTS
; ロイヤリティフリー ... ろろろろ
$EAFD $EAFE $EAFF $EB00 $EB01 $EB03 $EB04 $EB06 $EB08
税
人民解放軍
$FD $2005; $FC $2005; $FF 2000ドル
アメリカ手話 テイ インド 人民解放軍 STA $00 人民解放軍 STA $01
LDA ($00),Y 税

 Machine Translated by Google
$EB09
$EB0A LDA ($00),Y $EB0C STA $01 $EB0E 00ドル EB10ドル JMP ($0000)
$EB13 LDA $FB EB15ドル かつ #$f8 $EB17 STA $FB $EB19 オラ#$05 $EB1B STA $4016;
$EB1E
$EB1F
$EB20
$EB21
$EB22
$EB23
$EB24 LDX #$08 $EB26 LDA $FB $EB28 オラ#$04 $EB2A STA $4016; $EB2D LDY #$0a
デイ EB30ドル BNE $EB2F
[NES] ポート #1 のジョイパッドと I/O ポート
[NES] ポート #2 のジョイパッドと I/O ポート
[NES] ポート #1 のジョイパッドと I/O ポート
[NES] ポート #2 のジョイパッドと I/O ポート
$EB2F
$EB32
EB35ドル LDA $4017;
いいえ $EB33 LDY$FB
LSR A $EB39 そして #$0f $EB3B BEQ $EB62
$EB3D STA $00,X $EB3F LDA $FB $EB41 オラ#$06 $EB43 STA $4016; EB46ドル LDY #$0a
EB38ドル
EB48ドル
EB49ドル BNE $EB48
EB4Bドル
$EB4C
$EB4D LDA $4017;
EB50ドル
EB51ドル
$EB52
$EB53 そして #$f0
インド
いいえ いいえ いいえ いいえ いいえ いいえ
デイ
いいえ
いいえ
ロールA ロールA ロールA
[NES] ポート #1 のジョイパッドと I/O ポート

 Machine Translated by Google
EB55ドル オラ $00,X EB57ドル EOR #$ff EB59ドル STA $00,X
$EB5E LDY$FB EB60ドル オラ#$ff $EB62 STY 4016ドル;
EB5Bドル
デックス $EB5C BPL $EB26
EB65ドル
RTS
; ロイヤリティフリー ... ろろろろ
;CPU から PPU へのコピー ル ーチン ;
; ロイヤリティフリー ... ろろろろ
;CPUtoPPUcpy は、PPU と CPU 間のデータ転送に使用されます。
;引数はCPUレジスタに渡され、また即値としてハードコードされる。 ;呼び出し命令の後の value。
;パラメーター ;‐‐‐‐‐‐‐‐‐‐
;[RETaddr+1]はCPU転送アドレス(JSR命令の直後の2バイト)
;X reg: PPU との間で転送する 16 バイト単位の数
;Y reg: PPU 転送アドレスのビット 8‐15
;A reg: PPU xfer addr の下部、および xfer control。 ビットレイアウト
以下のとおりであります:
;
; 0: データ/塗りつぶしタイプを反転
; 1: 転送方向 (0 = ビデオ メモリに書き込み)
[NES] ポート #1 のジョイパッドと I/O ポート

 Machine Translated by Google
; 2‐3: 転送モード。各反復で、8バイトの2つのグループが 常にPPUに転送されますが、
;の ;
; は
;
; ; ; ; ; ;
モードでは、8バイトまたは16バイトがCPUとの間で転送されます。 この図はCPU経由でPPUとの間でどのように転送されるかを示しています 作った。
最初の8バイト 2番目の8バイト ‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐
0: CPU CPU+8
1: CPUフィルビット
2: ビットCPUを埋める
3: CPU ^ 反転ビットCPU
の
; 4‐7: PPU転送アドレスのビット4‐7。ビット0‐3は想定される 0.
;[$00]の単語を8増加します。 ;[$02]のバイトを減算します。
Inc00by8:LDA #$08 Inc00byA:PHP $EB69 LDY #$00 $EB6B CLC $EB6C
$EB6E $EB70 $EB72 $EB74 $EB76 $EB77 $EB79
ADC $00 STA $00 LDA #$00 ADC $01 STA $01 PLP
12月 $02 RTS
;word[$00]が指す8バイトをビデオバッファに移動します。
;キャリーが設定されている場合は移動方向が逆になります。 Mov8BVid:LDX #$08
$EB7C BCS $EB88
$EB7E LDA ($00),Y
$EB80 STA $2007; $EB83 $EB84
インド デックス
[NES] VRAMデータ

 Machine Translated by Google
$EB85 BNE $EB7C
RTS
$EB88 LDA $2007;
$EB8B STA ($00),Y $EB8D BCS $EB83
$EB87
;[$03]のバイトをビデオバッファに8回移動します。 ;キャリーが設定されている場合は、ダミー読み取りを行います。
FillVidW8B: LDA $03
$EB91 LDX #$08
$EB93 BCS $EB9C
$EB95 STA $2007; $EB98 $EB99
[NES] VRAMデータ
[NES] VRAMデータ
$EB9B $EB9F
デックス $EB9C BNE $EB93
RTS
LDA $2007; BCS $EB98
;word[$00]が指す8バイトをビデオバッファに移動します。
;データは移動される前に[$03]とXOR演算されます。 Mov8BtoVid: LDX #$08
$EBA3 LDA $03
$EBA5 EOR ($00),Y
$EBA7 STA $2007; $EBAA $EBAB
[NES] VRAMデータ
$EBAC $EBAE
インド
デックス
BNE $EBA3 RTS
;レジスタ変数を一時メモリにロードする CPUからPPUcpy: STA $04
$EBB1 STX $02
$EBB3 スタイル$03
[NES] VRAMデータ
$EBB5 JSR GetHCparam; ハードコードされたパラメータを [$00] と [$01] にロードします
;PPUアドレスの増分を1に設定 $EBB8 LDA 2002ドル; $EBBB LDA $FF $EBBD そして #$fb $EBBF スタ $FF $EBC1 STA 2000ドル
;PPUアドレスHI:=[$03] ;PPUaddrLO:=[$04]および$F0
[NES] PPUステータス
[NES] PPU セットアップ #1

 Machine Translated by Google
$EBC4 $EBC6 $EBC9 $EBCB $EBCD
LDY $03 STY $2006; LDA $04 そして #$f0 STA $2006;
[NES] VRAMアドレス選択
[NES] VRAMアドレス選択 クリアの場合は0、‐1
;[$03]:=ビット(0,[$04]) $EBD0 LDA #$00 $EBD2 STA $03 $EBD4 LDA $04 $EBD6 そして #$0f
設定されている場合
LSR A $EBD9 BCC $EBDD
$EBD8
$EBDB 12月 $03
;Bit(1,[$04])の場合、Temp:=[$2007]
LSR A $EBDE BCC $EBE3
$EBE0 バ LDX 2007 ドル; ッファ
;case [$04]および$0Cの
$EBDD
内部読み取りを検証するためのダミー読み取り
00xx 01xx 02xx
;$0C: #2 平面コピー (平面 1 は同じデータで埋められますが、反転できます)
テイ
$EBE4 BEQ $EBFB;
$EBE3
デイ
$EBE7 BEQ $EC09;
$EBE6
デイ
$EBEA BEQ $EC15;
$EBE9
$EBEC DEY;Y=0
JSR Mov8BtoVid $EBF0 LDY #$00
$EBED
$EBF2
$EBF5 JSR Inc00by8 $EBF8 BNE $EBED
RTS ;$00: ダブルプレーンコピー
$EBFA
$EBFB
$EBFE
$EC01 LDA #$10 $EC03 JSR Inc00byA $EC06 BNE $EBFB
JSR Mov8BVid
JSR Mov8BVid
JSR Mov8BVid

 Machine Translated by Google
RTS
;$04: #1 平面コピー (平面 2 は [$03] で埋められます)
$EC08
$EC09
$EC0C
$EC0F JSR Inc00by8 $EC12 BNE $EC09
JSR Mov8BVid JSR フィルVidW8B
RTS
;$08: #2 平面コピー (平面 1 は [$03] で埋められます)
JSR フィルVidW8B JSR Mov8BVid
$EC14
$15
$EC18
$EC1B JSR Inc00by8 $EC1E BNE $EC15
$EC20
RTS
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
$EC21
$EC22 $EC24 $EC26 $EC28 $EC2A $EC2C $EC2D $EC2F 30ドル $EC31 $EC32 $EC33 $35 円 $EC37 $39 円 $EC3B $EC3D $EC3F
RTS
LDY #$0b LDA ($00),Y STA $02 LDA #$02 STA $03 デイ
LDA ($00),Y LSR A
LSR A
LSR A
LSR A
BEQ $EC21 STA $04 STA $0C LDA ($00),Y そして #$0f BEQ $EC21 STA $05

 Machine Translated by Google
$EC41 $EC43 $45 円 $EC46 $EC47 $49 円 $EC4B $EC4D $EC4F $EC51 $EC53 $55 円 $EC56 $58 円 $EC5A $EC5C $EC5D $EC5F $60 円 $EC62 $EC64 $EC66 $EC68 $EC6A $EC6C $EC6E $70円 $EC72 $EC74 $EC76 $EC78 $EC7A $EC7C $EC7D $EC7F $EC81 $EC83 $EC84 $EC86 $EC87 $EC88 $89 円 $EC8B $EC8D $EC8E
LDY#$01
LDA ($00),Y 税
デイ
LDA ($00),Y
BEQ $EC4F
BPL $EC21
LDX #$f4
STX $08
LDY #$08
LDA ($00),Y LSR A
そして #$08 BEQ $EC5C
LDA #$80 ROR A
STA $09 インド
LDA ($00),Y そして #$23 オラ$09 STA $09 LDY #$03 LDA ($00),Y STA $0A LDA $05 STA $07 LDY #$00 STY 00億ドル LDA $04 STA $06 LDX $08 TXA
STA ($02),Y CMP #$f4 BEQ $EC87 CLC
ADC #$08 税
インド インド
LDA $09
STA ($02),Y インド
LDA $0A

 Machine Translated by Google
$90円 STA ($02),Y
$95円 12月 $06 $EC97 BNE $EC7C 99ドル LDA $0A
$EC92
インド $EC93 INC $0B
CLC $EC9C ADC #$08
$EC9E STA $0A $ECA0 12月 $07 $ECA2 BNE $EC76 $ECA4 LDY #$07 $ECA6 LDA ($00),Y $ECA8 STA $07
デイ
EC90億ドル
$ECAA
$ECAB LDA ($00),Y カナダドル STA $08 $ECAF LDA #$00 $ECB1 STA $0A
CLC
$ECB4 LDX 00億ドル
$ECB3
デイ
$ECB7 LDA ($00),Y
$ECB6
CLC $ECBA ADC $07 $ECBC STA $07
$ECBE LDA #$00 $ECC0 ADC $08 $ECC2 STA $08
$ECC7 INC $02 $ECC9 LDY #$00 $ECCB LDA $08 $ECCD BNE $ECD3 $ECCF 12月 $0A $ECD1 LD$07 $ECD3 ビット $09 $ECD5 BMI $ECF5 $ECD7 BVS $ECF7 $ECD9 LDA ($07)、Y $ECDB ビット $0A $ECDD BPL $ECE0
$ECB9
$ECC4
デックス $ECC5 BNE $ECB7
$ECDF
ありがとう
$ECE0 STA ($02,X)

 Machine Translated by Google
デイ $ECE3 ビット $09
$ECE5 BMI $ECE9
$ECE2
$ECE7
$ECE8
$ECE9 LDA #$04
CLC $ECEC ADC $02 $ECEE STA $02
$ECF0 12月 00億ドル $ECF2 BNE $ECD9
$ECEB
$ECF4
RTS
$5ユーロ BVC $ED09
$ECF7
$8ユーロ
$ECF9 ADC 00億ドル
テイ
デイ
$ECFB
$ECFC
$ECFD ビット $09 $ECFF BMI $ECD9 $ED01 LDA #$ff $ED03 EOR $0C $ED05 STA $0C $ED07 INC $0C
$ED09
$ED0A
$ED0B ADC $0C
テイ $ED0E LDA $04 10ドル STA $06
$ED0D
デイ $ED13 ビット $09
15ドル BMI ED19ドル
$ED12
$ED17
$ED18
$ED19 LDA ($07)、Y 10億ドル ビット $0A $ED1D BPL $ED20
$ED1F
ED20ドル STA ($02,X) $ED22 LDA #$04
CLC 25ドル ADC $02
ED24ドル
インド
インド
ありがとう
CLC
ありがとう
CLC
インド インド
ありがとう

 Machine Translated by Google
27ドル STA $02
29ドル 12月 $06 ED20億ドル BNE ED12ドル
$ED2D
$ED2E
$ED2F ADC $0C
テイ ED32ドル 12月 $05
31ドル
ED34ドル BNE $ED09
36ドル
RTS
ありがとう
CLC
24242424242424242424241712171D0E 170D1824282424242424242424242424 2424242424240F0A16121522240C18 16191E1D0E1B241D1624242424242424 24242424242424242424242424242424 24242424242424242424242424242424 24241D11121C24191B180D1E0C1D2412 1C24160A171E0F0A0C1D1E1B0E0D2424 24240A170D241C18150D240B22241712 171D0E170D18240C1827151D0D262424 2424181B240B2224181D110E1B240C18 16190A1722241E170D0E1B2424242424 242415120C0E171C0E24180F24171217 1D0E170D18240C1827151D0D26262424
;ディスク関連のサブルーチンが、どういうわけかここまで来ました...
スタートモーター: ORA #$01 $EE19 STA $4025
$EE1C と #$fd
$EE1E スタ $FA
$EE20 STA $4025 $EE23 リアルタイム
; ロイヤリティフリー ... ろろろろ
;ベクトルを リセットします。
; ロイヤリティフリー ... ろろろろ

 Machine Translated by Google
;割り込みを無効にします (リセットしても無効にならない場合に備えて) リセット: セイ
;PPU 制御レジスタ #1 を設定
$EE25 LDA #$10
$EE27 STA 2000ドル [NES] PPU セットアップ #1 $EE2A スタ $FF
;10進フラグをクリアします(このコードが10進モードのCPUで実行される場合) $EE2C 終了
;PPU Ctrl レジスタ #2 を設定 (プレイフィールドとオブジェクトを無効にする) $EE2D LDA #$06
$EE2F STA $FE
$EE31 STA $2001; [NES] PPU セットアップ #2
;少なくとも1フレーム待つ
$EE34 LDX #$02;ループ回数 = 2 回の繰り返し
$EE36 LDA 2002ドル; [NES] PPUステータス $EE39 BPL $EE36; VBLに達していない場合は分岐
X = 0 のときにループを終了する
タイマー割り込みを無効にする サウンドとディスクI/Oを無効にする
サウンドとディスクI/Oを有効にする
[NES] ポート #1 のジョイパッドと I/O ポート
[NES] オーディオ ‐ DPCM コントロール [NES] ポート #2 のジョイパッドと I/O ポート [NES] IRQステータス / サウンドの有効化
CPU
30億ドル
デックス $EE3C BNE $EE36;
$EE3E STX 4022ドル; $EE41 STX 4023ドル; $EE44 LDA #$83 $EE46 STA $4023; $EE49 STX $FD 40億ドル STX $FC $EE4D STX $FB $EE4F STX 4016ドル; $EE52 LDA #$2e $EE54 STA $FA $EE56 STA $4025 $EE59 LDA #$ff 50億ドル スタ $F9 $EE5D STA $4026 $EE60 STX 4010ドル; $EE63 LDA #$c0 $EE65 STA $4017; $EE68 LDA #$0f $EE6A STA $4015; $EE6D LDA #$80

 Machine Translated by Google
$EE6F STA $EE72 LDA $EE74 STA $EE77 LDX
$4080
#$e8
$408A #$ff;スタックのセットアップ
#$c0 $0100 #$80 $0101
TXS $EE7A LDA $EE7C STA $EE7F LDA $EE81 STA
$EE79
;if ([$102]=$35)and(([$103]=$53)or([$103]=$AC)) ; [$103]:=$53
; RstPPU05を呼び出す ; CLI
; JMP [$DFFC]
$EE84 LDA $0102 $EE87 CMP #$35 $EE89 BNE $EEA2 80億ドル LDA $0103 $EE8E CMP #$53 $EE90 BEQ 90億ドル $EE92 CMP #$ac $EE94 BNE $EEA2 $EE96 LDA #$53 $EE98 STA $0103
;I:=$F8 から $01 まで [I]:=$00 を実行します $EEA2 LDA #$00
$EEA4 LDX #$f8
$EEA6 STA $00,X
;[$300]:=$7D ;[$301]:=$00 ;[$302]:=$FF
$EEAB STA $0301 $EEAE LDA #$7d $EEB0 STA $0300 $EEB3 LDA #$ff $EEB5 STA $0302
それから
JSR RstPPU05
90億ドル
$EE9E CLI; 割り込みを有効にする
$EE9F JMP ($DFFC)
$EEA8
デックス $EEA9 BNE $EEA6

 Machine Translated by Google
;Ctrlr1 = $30の場合 ; [$0102]:=0
; JMP $F4CC
JSR 取得CtrlRsts
$EEBB LDA $F7; Ctrl 1 ボタンを読み取る
$EEBD CMP #$30;選択と開始のみが押された場合のテスト $EEBF BNE $EEC9
$EEC1 LDA #$00
$EEC3 STA $0102
$EEC6 JMP $F4CC
$EEB8
JSR 初期化Gfx $EECC JSR $F0FD
$EECF LDA #$4a $EED1 STA $A1 $EED3 LDA #$30 $EED5 STA $B1 $EED7 LDA #$e4 $EED9 STA $83 $EEDB LDA #$a9 $EEDD STA $FC
;ディスクが挿入されているかどうかをテストする
$EEC9
$EEDF $EEE2 です $EEE4 です
$EEE6 です $EEE8 です $EEEA $EEEC $EEEE $EEF1 $EEF4 $EEF6 $EEF8 $EEFA $EEFC $EEFE $EF01 $EF04 $EF07 $EF0A $EF0C $EF0E
LDA $4032 そして #$01 BEQ $EEEA
LDA #$04 STA $E1
LDA #$34 STA $90
JSR $F376 JSR VINTwait LDA 90ドル CMP #$32 BNE $EEFE LDA #$01 STA $E1
JSR $F0B4 JSR RstPPU05 JSR エンPfOBJ JSR $EFE8 LDX #$60
LDY #$20
JSR 乱数生成器

 Machine Translated by Google
$EF11 $EF14 $EF17 $EF19 $EF1C $EF1E $EF21 $EF23 $EF25 $EF27 $EF29 $EF2C $EF2E 30ドル $EF33 $EF36 $EF38 $EF3A $EF3C $EF3E 40ドル $EF42 $EF44 $EF46 $EF49 $EF4C $EF51 EF56ドル $EF59 フ ァイル EF60ドル $EF62 $EF65 $EF67 $EF6A $EF6C $EF6E $EF71 $EF74 $EF77 $EF7A $EF7D $EF7F $EF81 $EF83
JSR $F143
JSR $F342
LDX #$00
JSR $F1E5
LDX #$10
JSR $F1E5
LDA #$c0
STA $00
LDA #$00
STA $01
JSR $EC22
LDA #$d0
STA $00
JSR $EC22
LDA $4032
そして #$01
BNE $EEEA
LDA $FC
BEQ $EF42
LDA #$01
STA $FC
LDA90ドル
BNE $EEEE
JSR DisOBJs
JSR VINTwait
JSR PPUdataPrsr、$EFFF JSR PPUデータPrsr、$F01C JSR RstPPU05
JSR LoadFiles,$EFF5,$EFF5;FDSディスクブートをロードします
BNE $EF6C JSR $F431 BEQ $EFAF JSR $F5FB LDA #$20
STA $23
JSR 初期化Gfx JSR $F0E1 JSR $F0E7 JSR $F0ED JSR $F179 LDA #$10
STA $A3
LDA $22 BEQ $EF80億

 Machine Translated by Google
$EF85 LDA #$01 $EF87 STA $83 $EF89 12月 $21 EF8Bドル JSR $F376
JSR EnPF
$EF8E
$EF91 JSR $E86A
$EF94
EF97ドル
$EF9A JSR $EFE8 $EF9D LDA #$02 $EF9F STA $E1 $EFA1 LDA $A3 $EFA3 BNE 80億ドル $EFA5 LDA $4032 $EFA8 そして #$01 $EFAA BEQ $EFA5
$EFAC
JMPリセット
$EFAF LDA #$20 $EFB1 STA $A2
$EFBE
$EFBF
$EFC0 CPX #$b0 $EFC2 BCS $EFC6 $EFC4 STX $FC $EFC6 JSR $EFE8 $EFC9 LDA $A2 $EFCB BNE $EFB3 $EFCD LDA #$35 $EFCF STA $0102 $EFD2 LDA #$ac $EFD4 STA $0103
$EFB3
$EFB6
$EFB9
$EFBC LDX $FC
JSR ディスPF $EFDA LDY #$07
$EFDC JSR $F48C $EFDF LDA #$00 $EFE1 STA $FD $EFE3 STA $FC $EFE5 JMP 90億ドル
$EFD7
JSR VINTwait
JSR RstPPU05
JSR VINTwait JSR RstPPU05 JSR EnPF
インクス
インクス

 Machine Translated by Google
$EFE8 JSR $FF5C $EFEB LDX #$80 $EFED LDA #$9f $EFEF LDY #$bf $EFF1 JSR $E9D3
$EFF4
RTS
FFFFFFFFFFFF0000FFFF
21A6 54 24 FF
$EFFF
$F004
FF
$F01C
FF
21A6 14 19150E0A1C0E241C0E1D240D121C14240C0A1B0D
21A6 0E 1718202415180A0D121710262626
0D121C14241C0E1D0B0A1D1D0E1B2224 0A250B241C120D0E0D121C1424171826 21A6140D121C14241D1B181E0B150E24 240E1B1B260200FF20E810191B0A1624 0C1B0A16242424242418142168041918 1B1D3F00080F200F0F0F0F0F0F2BC050 002BD07055FF
;$F094 80B80000000000001000320000000100 80B800F000000000000132180000FF00
$F0B4 LDA $FC $F0B6 BEQ $F0C0 $F0B8 12月 $FC $F0BA BNE $F0C0 $F0BC LDA #$10 $F0BE STA $94 $F0C0 LDX94ドル $F0C2 BEQ $F0CD
$F0C4
デックス $F0C5 BEQ $F0E1
$F0C7
デックス $F0C8 BEQ $F0E7

 Machine Translated by Google
$F0CA
デックス $F0CB BEQ $F0ED
$F0CD JSR $E9C8
$F0D0 JSR $E86A
$F0D3 LDA92ドル
$F0D5 BNE $F0F3
$F0D7 JSR PPUdataPrsr、$EFFF $F0DC LDA #$40
$F0DE STA $92
$F0E0
RTS
$F0E1 JSR PPUデータPrsr、$F716
$F0E6
RTS
$F0E7 JSR PPUデータPrsr、$F723
$F0EC
RTS
$F0ED JSR PPUデータPrsr、$F72C
$F0F2
RTS
$F0F3 CMP #$2e
$F0F5 BNE $F0FC
$F0F7 JSR PPUデータPrsr、$F004
$F0FC
RTS
; ロイヤリティフリー ... ろろろろ
;$0200‐$02FFを$F4で埋める $F0FD LDA #$f4 $0FF LDX #$02 $F101 LDY #$02
$F103
JSR メモリフィル
;データを移動する ;I:=0から$1Fまでの場合、[$C0+I]:=[$F094+I]を実行します
$F106 LDY #$20 $F108 LDA $F093,Y 100億ドル STA $00BF,Y
$F10E
デイ

 Machine Translated by Google
$F10F BNE $F108
;$0230‐$02FFをランダムデータで埋める ;I:=$0230から$02FFまでの場合、[I]:=Random(256)を実行します
$F111 LDA #$d0;ループ回数
$F113 STA $60; 任意のデータで乱数ターゲットをロード
$F115 STA $01; ループ回数を[$01]に保存します
$F117 LDY #$02
$F119 LDX #$60
$F11B JSR RndmNbrGen; 数値ター
ゲット
$F11E LDA $60; ランダムな番号を取得
[$60]と[$61]
ランダムです
$F120 LDX $01; ループカウント(およびインデックス)をロード
$F122 STA $022F,X; ランダムな番号を書き出す
$F125
$F126 STX $01; ループ回数を保存 $F128 BNE $F117
;ランダムデータ領域の4バイトごとに$33を入力します ;I:=0から$33までの場合、[I*4+$0231]:=$18を実行します
$F12A LDA #$18 $F12C LDX #$d0 $F12E STA $022D,X
$F142
RTS
; ロイヤリティフリー ... ろろろろ
$F143 LDA $84
デックス
$F131
$F132
$F133
$F134
$F135 BNE $F12E
;and & またはランダムデータの4バイトごと ;I:=0から$33までの場合、[I*4+$0232]:=([I*4+$0232]‐1)かつ$03または$20
$F137 LDX #$d0
$F139 STX24ドル $F13B JSR $F156 $F13E CPX #$d0
$F140 BNE 130億フラン
デックス デックス デックス デックス

 Machine Translated by Google
$F145 $F147 $F149 $14B フォックス $F14D $150 フラン $F151 $F152 $F153 $F154
BNE $F156
LDA #$04
STA $84
LDX #$d0
12月 $022C,X デックス
デックス
デックス
デックス
BNE $F14D
;I:=0から3の場合
; [$022E+X]:=([$022E+X]‐1)かつ$03または$20 ; X‐=4
; X=0 の場合、X:=$d0
;終わり
$F156 LDY #$04 $F158 LDX24ドル $F15A 12月 $022E,X $F15D LDA #$03 $F15F そして $022E,X $F162 オラ#$20 $F164 STA $022E,X
$F167
$F168
$F169
$F16A
$160億 BNE $F16F $F16D LDX #$d0 $F16F STX24ドル
デイ
$F172 BNE $F158
$F171 $F174
$F175
RTS
01 02 07 08 1000 01 02 07 08 01 02 07 08 01 02 07 08 10 ...
$F179 LDY #$18 $170億 LDA $F04D,Y $F17E STA $003F,Y
デイ
$F182 BNE 170億フラン
$F184 LDA $23 $F186 そして #$0f
$F181
デックス デックス デックス デックス

 Machine Translated by Google
$F188 $F18A $F18C $F18D $F18E $F18F $190 円 $F192 $F194 $F196 $F198 $F19A $F19D $F19E $F1A0 $F1A2 $F1A4 $F1A5 $F1A7 $F1AA $F1AC $F1AD $F1AE $F1AF $F1B0 $F1B1 $F1B3 $F1B4 $F1B7 $F1BA $F1BB $F1BD $F1C2
STA $56 LDA $23 LSR A LSR A LSR A LSR A
STA $55
CMP #$02
BEQ $F1BD
LDY #$0e
LDA #$24
STA $0042,Y デイ
BNE $F19A LDY #$05 LDA $23 デイ
BEQ $F1BD CMP $F174,Y BNE $F1A4 ありがとう アメリカ手話 アメリカ手話 アメリカ手話
税
LDY #$07 デックス
LDA $F02E,X
STA $0043,Y デイ
BPL $F1B3
JSR PPUデータPrsr、$0040 RTS
; ロイヤリティフリー ... ろろろろ
;フォントビットマップをPPUメモリにコピーする
;src:CPU[$E001] dest:PPU[$1000] タイル:41 (41*8 バイト、第 1 プレーンは反転)
フォントを読み込む:
$F1C5 LDY #$10
$F1C7 LDX #$29
$F1C9 JSR CPUからPPUcpy、$E001
LDA #$0d

 Machine Translated by Google
;反転フォントビットマップをPPUメモリから[$0400]にコピーします ;src:PPU[$1000] dest:CPU[$0400] タイル:41 (41*8 バイト)
$F1CE LDA #$06
$F1D0 LDY #$10
$F1D2 LDX #$29
$F1D4 JSR CPUからPPUcpy、$0400
;フォントをコピーして最初のプレーンをすべて 1 に設定します
;src:CPU[$0400] dest:PPU[$1000] タイル:41 (41*8 バイト、第 1 プレーンはすべて 1)
$F1D9 LDA #$09
$F1DB LDY #$10
$F1DD LDX #$29
$F1DF JSR CPUからPPUcpy、$0400
$F1E4
RTS
; ロイヤリティフリー ... ろろろろ
$F1E5 $F1E8 $F1EB $F1EE $F1F1
$F1F2 $F1F4 $F1F6 $F1F8 $F1FA $F1FC $F1FE $200 フラン $F202 $F204 $F206 $F208 $F209 200億ドル $F20D $F20F
JSR $F1F2 JSR $F2EC JSR $F273 JSR $F2C6 RTS
LDA $20,X
BNE $F227
LDA $C0,X
BNE $F227
LDA $B0
BNE $F227
LDA $81,X
BNE $F227
LDA $62,X
そして #$3c
STA $81,X TXA
BNE $F228 LDA $B2 BNE $F236 LDA $D0

 Machine Translated by Google
$F211 $F213 $F215 $F217 $F219 $21B フォリント $F21D $F21F $F221 $F223 $F225 $F227
$F228 $F22A $F22C $F22E $F230 $F232 $F234 $F236 $F238 $F23A $F23C
$F23D $F23F $F241 $F243 $F245 $F247 $F249 240億ドル $F24D $F24F $F251 $F253 $F255 $F257 $F259
BEQ $F23D LDA $22 BNE $F21D LDA $C3 CMP #$78
$F25A
LDA $64,X
BCC
LDA
STA
STA
LDA
STA RTS
LDA
BEQ
LDA
BNE
LDA
CMP #$80 BCS $F24D LDA #$00 STA $CF,X STA $CE,X RTS
LDA $C8
BNE $F247
LDA $63,X
CMP #$c0
BCC $F21D
LDA $64,X
CMP #$80
BCC $F236
LDA #$10
STA $C8,X
LDA #$00
STA $CF,X
LDA #$01
STA $CE,X RTS
$F24D #$00 $C8,X $CF,X #$ff $CE,X
$C0 $F25A
$22 $F21D
$63,X

 Machine Translated by Google
$F25C $F25E $F260 $F262 $F264 $F266 $F268 $F26A $F26C $F26E $270 円 $F272
$F273 $F275 $F277 $F279 $F27A $F27C $F27E $280 フラン $F282 $F284 $F286 $F287 $F289 280億ドル $F28D $F28F $F291 $F293 $F295 $F296 $F298 $F29A $F29C $F29E $F2A0 $F2A2 $F2A4 $F2A6 $F2A8 $F2AA
LDY $C8 BEQ $F264 CMP #$40 BCC $F24D CMP #$c0 BCC $F236 LDA #$40 STA $CF,X LDA #$00 STA $CE,X STA $C8,X RTS
LDA $20,X BEQ $F2AA
BMI CLC
LDA
ADC
STA
LDA
ADC
STA
CLC
LDA
ADC
STA
LDA
ADC
CMP #$b8 BCC $F2A4 TXA
BNE $F2B6 LDA $60,X そして #$30 STA $81,X LDA #$00 STA $20,X LDA #$b8 STA $C1,X LDA #$03 STA $C5,X RTS
$F2AB
#$30 $CD,X $CD,X #$00 $CC,X $CC,X
$CD,X $C2,X $C2,X $CC,X $C1,X

 Machine Translated by Google
$F2AB 12月 $20,X
$F2AD LDA $F2AF STA $F2B1 LDA $F2B3 STA
#$fd $CC,X #$00 $CD,X
$F2B5
RTS
$F2B6 STA
$F2B8 LDA
$F2BA STA
$F2BC LDA
$F2BE STA
$F2C0 LDA
$F2C2 STA
$F2C4 BNE $F29E $F2C6 LDA $B0 $F2C8 BNE $F2E7 $F2CA LDA $A1,X $F2CC BNE $F2E7 $F2CE LDA $C0,X $F2D0 BEQ $F2E7 $F2D2 LDA $62,X $F2D4 オラ#$10 $F2D6 そして #$3c $F2D8 STA $81,X $F2DA LDY #$10 $F2DC LDA $F094,X $F2DF STA $C0,X
$F2E1
$F2E2
$F2E3 BNE $F2DC $F2E5 スタイル $B0,X
$F2E7
$F2E8
インクス
デイ
RTS
00020102
$F2EC LDA $C0,X $F2EE BNE $F329
$F2F0
$F2F1 LDA $CF,X $F2F3 ADC $C4,X
CLC
$C8,X #$01 $CE,X #$c0 $CF,X #$ff $81,X

 Machine Translated by Google
$F2F5 $F2F7 $F2F9 $F2FB $F2FD $F2FF $F301 $F303 $F305 $F307 $F309 300億ドル $F30D $F30F $F311 $F313 $F315 $F317 $F318 $F319 $31B フォックス $F31C $F31E $F320 $F322 $F324 $F327 $F329
$F32A $F32C $F32E $330 円 $F332 $F334 $F336 $F338 $F33A $F33C $F33E $340 フラン $F342 $F344 $F346
STA $C4,X LDA $CE,X ADC $C3,X LDY $B0 CPY #$20 BCS $F315 CMP #$f8 BCC $F32A CPY #$1f BCS $F315 LDA $60,X そして #$2f オラ#$06 STA $A1,X LDA #$80 STA $C0,X STA $C3,X LSR A
LSR A
そして #$03 テイ
LDA $CE,X ORA $CF,X BNE $F324 LDY#$01 LDA $F2E8,Y STA $C5,X RTS
CMP #$78
BNE $F315 CPX22ドル BNE $F315 1日20ドル
BNE $F315
LDY #$00 スタイル $CE,X STY $CF,X
LDY #$80 スタイル $20,X BNE $F315
LDA $B0
BNE $F36D
LDA $C0

 Machine Translated by Google
$F348 $F34A $F34C $F34D $F34F $F351 $F353 $F355 $F357 $F359 350億ドル $F35D $F35F $F361 $F363 $365 円 $F367 $F369 $360億 $F36D
$F36E
$F376 $F378 $F37A $F37C $F37E $380 フラン $F382 $F384 $F386 $388 円 $F38A $F38C $F38E $390 フラン $392 円 $F394 $F396 $398 円 $F39A $F39C
オラ $D0 BNE $F36D CLC
LDA $C3 ADC #$19 CMP$D3 BCC $F36D スタ $D3 LDA #$02 STA $CE STA $DE LDA #$00 STA $CF STA $DF LDA #$10 STA $C8 スタ $D8 LDA #$30 STA $B0 RTS
DB2A0A2505
LDY #$08 LDA $83 BNE $F3C8 LDA93ドル BNE $F3EF LDX #$00 LDA $C1,X CMP #$a4 BCS $F39E LDA #$20 LDY $B2 BNE $F39C LDA #$08 1泊65ドル CPY #$18 BCS $F39C LDA #$08 STA $B2 LDA #$20 STA $83,X
21 01 27 16

 Machine Translated by Google
$F39E CPX #$10
$F3A0 LDX #$10
$F3A2 BCC $F382 $F3A4 LDA $22
$F3A6 BEQ $F3C7 $F3A8 LDA $82
$F3AA BNE $F3C7 $F3AC LDA #$08
$F3AE STA $82
$F3B0 LDX #$0f
$F3B2 LDA47ドル $F3B4 CMP #$0f
$F3B6 BNE $F3BA $F3B8 LDX #$16
$F3BA STX47ドル $F3BC LDA #$3f
$F3BE LDX #$08
$F3C0 LDY #$08
$F3C2 JSR $E8D2,$0040
$F3C7
RTS
$F3C8 LDA $F634,Y $F3CB STA $003F,Y
デイ
$F3CF BNE $F3C8
$F3D1 INC $21 $F3D3 LDA $21 $F3D5 そして #$06
テイ
$F3CE
$F3D7
$F3D8 LDA $F36E,Y $F3DB STA $42 $F3DD LDA $F36F,Y $F3E0 STA $43 $F3E2 LDY #$00 $F3E4 LDA $B2 $F3E6 BNE $F3EA $F3E8 LDY #$10 $F3EA スタイル 22 ドル $F3EC JMP $F3BC
$F3EF LDA $F63F,Y
$F3F2 STA $003F,Y
$F3F5
デイ

 Machine Translated by Google
$F3F6 BNE $F3EF $F3F8 BEQ $F3EA
; ロイヤリティフリー ... ろろろろ
;グラフィックスを初 期化します。
; ロイヤリティフリー ... ろろろろ
;このサブルーチンはパターンテーブルをROMからVRAMにコピーし、また
;名前とパレットテーブルを設定します。
;エントリーポイント
InitGfx: JSR DisPfOBJ; オブジェクトとプレイフィールドを無効にする ビデオ転送
;src:CPU[$F735] dest:PPU[$1300] xfer:88タイル $F3FD LDA #$00
$F3FF LDX #$58
$F401 LDY #$13
$F403 JSR CPUからPPUcpy、$F735
;src:CPU[$FCA5] dest:PPU[$0000] xfer:25タイル $F408 LDA #$00
$F40A LDX #$19
$F40C LDY #$00
$F40E JSR CPUからPPUcpy、$FCA5
$F413 JSR LoadFonts; メモ
;宛先:PPU[$2000] NTfillVal:=$6D ATfillVal:=$aa $F416 LDA #$20
$F418 LDX #$6d
$F41A LDY #$aa
ROMからビデオにフォントをロードする
$F41C
JSR VRAMフィル
;宛先:PPU[$2800] NTfillVal:=$6D ATfillVal:=$aa $F41F LDA #$28
$F421 LDX #$6d
$F423 LDY #$aa

 Machine Translated by Google
$F425
$F428 $42B フォリント $430 円
JSR VRAMフィル
JSR VINTwait
JSR PPUdataPrsr、InitNT;名前テーブルを初期化する RTS
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
; ロイヤリティフリー ... ろろろろ
$F431 $F434 $F436 $F439 $F43C $F43F $F444 $F446 $F448 $F44A $F44D $F44F $F451 $F453 $F456 $F459 450億ドル $F45E $460 円 $F463 $F466 $F468 $46B フォリント $F46E $470 円 $F471 $F473 $475 円 $478 円
JSR ディスパッチOBJ LDY #$03
JSR $F48C
JSR ロードフォント JSR VINTwait
JSR PPUデータPrsr、$F080 LDA #$20
LDX #$28
LDY #$00
JSR VRAMフィル LDA $FF
そして #$fb スタ$FF
STA 2000ドル LDX 2002ドル; LDX #$28
STX 2006ドル; LDA #$00
STA $2006; LDA $2007; LDY #$00
LDA $2007; CMP$ED37,Y BNE $F483 インド
CPY #$e0 BNE $F468 STX 2006ドル; STY $2006;
[NES] PPU セットアップ #1 [NES] PPUステータス
[NES] VRAMアドレス選択
[NES] VRAMアドレス選択 [NES] VRAMデータ
[NES] VRAMデータ
[NES] VRAMアドレス選択 [NES] VRAMアドレス選択

 Machine Translated by Google
$470億 $F47D $480 フラン $F481 $F483
$F484
$F48C $F48E $F491 $F493 $F494 $495 円 $F497 $499 フラン $490億 $F49D $F49F $F4A1 $F4A6 $F4A8 $F4AA $F4AC $F4B1 $F4B3 $F4B4 $F4B6 $F4B9 $F4BC $F4BE $F4C1 $F4C4 $F4C5 $F4C7 $F4C9 $F4CB
$F4CC $F4CE $F4D0 $F4D2
LDA #$24
STA $2007; インド
BNE 470億フラン RTS
[NES] VRAMデータ
02301029デービッド 32002910
LDX #$03
LDA $F484,Y
STA $07,X デイ
デックス
BPL $F48E
LDA #$29
STA 00億ドル
LDA $07
LDX #$01
LD$09
JSR CPUからPPUcpy、$0010
LDA $08
LDX #$01
LD$0A
JSR CPUからPPUcpy、$0010
LDY#$01
CLC
LDA #$10
ADC $0007,Y
STA $0007,Y
LDA #$00
ADC $0009,Y
STA $0009,Y デイ
BPL $F4B3
12月 00億ドル BNE 490億フラン RTS
LDA #$20
LDX #$24
LDY #$00
JSR VRAMフィル

 Machine Translated by Google
$F4D5 $F4D8 $F4DD $F4E0 $F4E2 $F4E4 $F4E6 $F4E8 $F4ED $F4EF $F4F1 $F4F3 $F4F8 $F4FA $F4FC $F4FE $F503 $F505 $F507 $F509 $F50E $F510 $F512 $F514 $F516 $F518 $F51A $F51C $F51F $F521 $F523 $F525 $F527 $F529 $52B ... $F52D $F52F $F530 $F532 $F535 $F536 $F537 $F538 $F539 $F53A
JSR VINTwait
JSR PPUデータPrsr、$F066 JSR $F5FB
BNE $F527
LDA #$00
LDX #$00
LDY #$00
JSR CPUからPPUcpy、$C000
LDA #$00
LDX #$00
LDY #$10
JSR CPUからPPUcpy、$D000
LDA #$02
LDX #$00
LDY #$00
JSR CPUからPPUcpy、$C000
LDA #$02
LDX #$00
LDY #$10
JSR CPUからPPUcpy、$D000
LDA #$C0
STA $01
LDY #$00
スタイル $00
LDX #$20
LDA #$7f
ADC #$02
JSR $F61B
BEQ $F54E
LDA $01
そして #$03
STA $01
LDA #$11
STA 00億ドル
LDY #$03
LDA $00 税
そして #$0F
STA $0007,Y デイ
TXA
LSR A
LSR A LSR A LSR A

 Machine Translated by Google
$530億 $F53E $540 円 $F541 $F543 $F545 $F547 $F549 $F54E $F551 $F554 $F556 $F558 $F55A $F55F $F562 $F565 $F568
STA $0007,Y LDA $01 デイ
BPL $F52F
LDA #$20
LDX #$f4
LDY #$05
JSR $E8D2,$0007 JSR ロードフォント JSR 取得CtrlRsts LDA $F7
CMP #$81 BNE $F5B8
JSR PPUデータPrsr、$F56B JSR VINTwait
JSR RstPPU05
JSR EnPF
JMP $F568
20E7 11 020C03032412171D0E1B170A15241B1816
2163 19 191B18101B0A160E0D240B22241D0A140A18241C0A200A1718
21A3 19 1712171D0E170D18240C1827151D0D26240D0E1F2617182602
$F5B8 $F5BA $F5BC $F5BE $F5BF $F5C0 $F5C1 $F5C4 $F5C7 $F5CA $F5CD $F5CF $F5D1 $F5D2 $F5D3 $F5D6 $F5D7
LDA #$01 スタ $0F LDA #$ff CLC
PHA
PHP の
JSR VINTwait JSR $E86A JSR RstPPU05 JSR EnPF 12月 $0F
BNE $F5DD PLP
人民解放軍
STA $4026 ロールA
PHA
FF

 Machine Translated by Google
$F5D8
PHP の $F5D9 LDA #$19
$F5DB スタ $0F $F5DD LDA $4033 $F5E0 LDX #$07 $F5E2 LDY#$01
$F5E4
アメリカ手話 $F5E5 BCS $F5E8
デイ
$F5E8 スタイル $07,X
$F5ED LDA #$21
$F5EF LDX #$70
$F5F1 LDY #$08
$F5F3 JSR $E8D2,$0007 $F5F8 ジャンプ$F5C1
$F5FB LDA #$60 $F5FD LDX #$80 $F5FF STX $03
$F5E7
$F5EA
デックス $F5EB BPL $F5E2
PHA $F602 STA $01
$F604 LDY #$00 $F606 スタイル $00
$F601
CLV
$F609 JSR $F61B
$F60F スタイル $00 $F611 LDX $03 $F613 LDA #$7f $F615 ADC #$02 $F617 JSR $F61B
$F608
$F60C
人民解放軍 $F60D STA $01
$F61A
RTS
$F61B STX $02 $F61D LDA $02 $F61F BVS $F62E $F621 STA ($00),Y $F623 INC $02
デイ
$F626 BNE $F61D
$F625

 Machine Translated by Google
$F628 $F62A $62B 円 $F62D
$F62E $630 円 $F632 $F634
INC $01 デックス
BNE 610億フラン RTS
CMP ($00),Y BEQ $F623 スタイル $00 RTS
;$F635 0F3027160F100016
;PPUプロセッサデータ 初期化NT: 3F08 18
0F21010F0F0002010F2716010F27301A0F0F010F0F0F0F0F 20E4 02 6E73
20E6 54 77
20FA 02 787C
2104 02 6F74
2106 54 24
211A 02 797D
2124 C5 70
213B C5 70
2125 C5 24
213A C5 24
21C4 02 7175
21C6 54 24
21DA 02 7A7E
21E4 02 7276
21E6 54 77
21FA 02 7B7F
2126 14 3034383B3F2424474B24242424245D61242428 2146 14 3135323C404346484C4E513C54575A5E6265686B 2166 14 3236393D414432494D4F523D55585B5F6366696C 2186 14 33373A3E4245334A4550533E56595C6064676A24 21A6 54 24
220F C4 83 2210 C4 84 228F 02 8586 23E0 50 FF 23F0 48 AF FF

 Machine Translated by Google
2040 60 80 2020 60 81 2000 60 81 FF
2340 60 80 2360 60 81 FF
2380 60 82 23A0 60 82 FF
;パターンテーブルデータ ;$F735
FFC0C0C0C0C0C0C080BFBFBFBFBFBFBFB C0C0C0C0C0C0C0BFBFBFBFBFBFBFBFB C0C0C0C0C0C0C0BFBFBFBFBFBFBFBFB C0C0C0FFFFFFFFFFBFBFBFFFFFFFFFFFF 7F7F3F3F1F1F0F0FFFFFFFFFFFFFFFFF 078783C3C1E1E0F0FF7F7FBFBFDDFEF F0F8F8FCFCFEFEFFEFF7F7FBFBFDFDFE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF FFC0C0C0C0C0C0C080BFBFBFBFBFBFBFB 0000000000000000FFFFFFFFFFFFFFFF 008080FFFFFFFFFFFF7F7FFFFFFFFFFFF FFE0E0E0E0FFFFFFC0DFDFDFDFFFFFFF FFE0E0E0E0E0E0E0C0DFDFDFDFDFDFDF E0E0E0E0E0E0E0E0DFDFDFDFDFDFDFDF E0E0E0FFFFFFFFFFDFDFDFFFFFFFFFFF FF7F7F7F7FFFFFFF7FFFFFFFFFFFFFFF FF7070707070707060EFEFEFEFEFEFEF 707070707070707070EFEFEFEFEFEFEF 707070FFFFFFFFFFEFEFEFFFFFFFFFFF FF20000F1F1F3F3F20DFFFFEFFFFFFFF 3F3F3F3F3F3F3F3F3F3FFFFFFFFFFFFFFFFF 3F3F3FFFFFFFFFFFFFFFFFFFFFFFFFFF FF7F1F078181C0C07F9FE7FB7F7FBFBF FFFFFFFFFF0F0F0FFFFFFFFE0EFEF0F 8090F0F0F0F0F0F07F6FEFEFEFEFEFEFE F0F0F0F0F0F0F0F0EFEFEFEFEFEFEFEF F0F0F0FFFFFFFFFFEFEFEFFFFFFFFFFF FFFFFFFFFF3F3F3FFFFFFFFF3FFFFFC7 07073F3F3E3E3C3CFFFFFFFEFDFDFFBFB 3C3C3C3C3E3E3EFBFBFBFBFBFDFDFF

 Machine Translated by Google
FFE0800F1F1F1F3FE09F7FFFFFFFFFC0 00001F1F1F1F1F1F1FFFFFFFFFFFFFFF 0F80E0FFFFFFFFFFF0FFFFFFFFFFFFFF FF3F0FC7E1E1E0E03FCFF7BBDFDFDF1F 0000FFFFE0E1E1C3FFFFFFC0DFDFDFBF 870F3FFFFFFFFFFF7FFFFFFFFFFFFFFF FF40001C3F3F7F7F40BFFFFFFEFEFFFF 7F7F7F7F7F7F7F7F7F7FFFFFFFFFFFFFFFFF 7F7F7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF FFFF3F0F03038181FF3FCFF7FFFF7F7F 818181818181817F7F7F7F7F7F7F7F 818181FFFFFFFFFF7F7F7F7FFFFFFFFFFFF FFFCF0E0E0C0C0C0FCF3EFDFDFBFBFBF C0C0C0C0C0E0E0BFBFBFBFBFBFDFDF F0F0FCFFFFFFFFFFEFFFFFFFFFFFFFFF FFFEFEFEFEFEFEFEFCFDFDFDFDFDFDFD FE0602007CFEFEFE05F9FDFFFBFDFDFD FEFEFEFEFEFEFC78FDFDFDFDFDFD7B87 020206FFFFFFFFFFFDFDFDFFFFFFFFFF FF0707070707070707FFFFFFFFFFFFFF 0707070707070707FFFFFFFFFFFFFEFE 0707070707070707FEFEFEFEFEFFFFFF 070707FFFFFFFFFFFFFFFFFFFFFFFFFF FFF8E0C183870707F8E7DFBF7F7FFFFF 07070707078783C3FFFFFFFFFF7F7FBD E1E0F8FFFFFFFFFFDEFFFFFFFFFFFFFF FF0F03C1F0F8F8F80FF3FDFEEFF7F7F7 F8F8F8F8F8F8F0E0F7F7F7F7F7F7EFDF C1030FFFFFFFFFFF3FFFFFFFFFFFFFFFFF FFFFFFFF7F7F3F3FFFFFFFFFFFFFFFFF 3F3F3F3F3F7F7FFFFFFFFFFFFFFFFFFF 00000000000000000000000000000000 00000103060C18100003060C1933276F 30202060404040404F5EDC9CB9B9B9B9 4040404040404040B9B9B9B9B9B9B9 4040404060202020B9B9B9B99CDE5F5F 100000000000000006F3F3F1F0E070300 007FC00000000000FF803FFFFFF0C08F 071F3F7F7FFFFFFF3F7FFFFFFFFFFFFF FFFFFF7F7F3F1F07FFFFFFFFFFFFFFFF 100F000000000000EFF0FFFFFF0080FF 00FF000000000000FF00FFFFFF0000FF 00FA000000000000FF05FFFFFF3F1FFF E0F9FCFEFEFFFFFFFFFFFFFFFFFFFFFF FFFFFFEFEFCF9E3FFFFFFFFFFFFFEFC

 Machine Translated by Google
0EF80000000000000F107FFFFFC0001FF 0000000000000000000C0E0F0F8FCFCFE 0000808040404040FEFA7B79B9B9B9B9 40404040C0808000B9B9B9B9397372E2 0000000000000000E6C48C183060C000 00FF00FF00FF00FFFFFFFFFFFFFFFFFF FF00FFFFFF00FFFFFFFFFFFFFFFFFFFF FFFF00FFFFFFFFFFFFFFFFFFFFFFFFFF 06060606060606000000000000000000 60606060606060000000000000000000 1F5F505757501F002020AFA7A7AF603F F8FA0AEAEA0AF8000404F5E5E5F506FC
;$FCA5 000000000000031F00000003030F0002 3F1F0F0720707020041E000001030F1F 00040F1F0F0C00000F072F3F3F1C1800 000000000000F0F800000080E0F0F048 F8FCF8E010103226489C0800F0FCFCF8 7CF8F8FCFC780000F8F8F8FCFC7C1C38 000000000000000700000000007071F01 3F7F3F1F0F01C2C204083D0000070F1F C6071F1F0F0F00003F7F1D1F0F0F070F 00000000000000E00000000000C0E0E0 F0F0F8F0C00000009090381000E0F0F8 0C1CFCF8F8780000F0E0E0F4FE7E0200 000000000000031F00000003030F0002 3F1F0F0700010113041E000003070F0F 1F1F0F07070300000F0D0F0707030001 000000000000F0F800000080E0F0F048 F8FCF8E0800000C0489C0800E0F0F8F8 80C0F0F0F0E00000F8301030F0E0E0E0 001C1E0E0400000700000010183B3838 0F070303060C090F313F1C1E0F0F4F4F 1F1F1F07000000007E7F7F0700000000 000000000000FCFE000000E0F8FC3C92 FEFFFEF860C0838712A70200FCFEFCF0 D2F0E0F0F0600000F0F8FCFEF2600000 00000000000000008000000000000000
$35 フェデラル
$FE36 $FE37 $39 フェデラル
DBFFFの
LSR A
BCS $FE66 LSR $E1

 Machine Translated by Google
30億ドル $FE3D $FE3E $40 フェデラル $FE42 $FE44
$FE47 $49 フェールオーバー $FE4C $FE4E $FE51 $FE53 $55 フェデラル $FE57 $59 フェールオーバー 50億ドル $FE5E $FE61 $FE63 $FE66 $68 フェールオーバー $69 フェールオーバー 60億ドル $FE6D $FE6F $FE71 $FE74
$FE77
$FE7A $FE7C $FE7E $80 フェデラル $FE83 $FE86 $89 フェールオーバー $FE8C $FE8E $FE91 $FE93
BCS $FE47 LSR A
BCS $FEA6 LSR $E1
BCS $FE7A ジャンプ$FF6A
LDA #$10
STA 4000ドル; LDA #$01
STA $4008; スタイル$E3 LDA #$20
STA $E4
LDX #$5c
LDY #$7f
STX 4004ドル; STY 4005ドル; LDA #$f9
STA $4007; LDA $E4
LSR A
BCC $FE6F LDA #$0d BNE $FE71 LDA #$7c
STA $4006; JMP $FFC6
JMP $FFCA
スタイル$E3 LDX #$9c
LDY #$7f
STX 4000ドル; STX 4004ドル; STY 4001ドル; STY 4005ドル; LDA #$20
STA $4008; LDA #$01 STA $400C;
[NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ トライアングル
[NES] オーディオ ‐ スクエア2 [NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ スクエア2 [NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ トライアングル [NES] オーディオ ‐ ノイズ制御

 Machine Translated by Google
$FE96 $98 フェールオーバー $FE9A $FE9C $FE9E $FEA0 $FEA2 $FEA4 $FEA6 $FEA8 $FEAA $FEAC $FEAD $FEAF 2月2日 2月4日 2月7日 2月9日 $FEBA $FEBC $FEBE $FEC1 $FEC3 $FEC5 $FEC7 $FEC8 $FECA $FECD $FED0 $FED2 $FED3 $FED5 $FED7 $FEDA $FEDC $フェデ 手数料0ドル 手数料3ドル 手数料5ドル 手数料8ドル $FEEA $FEEB $フィード $FEF0 $FEF3
LDX #$00 STX $E9 STX $EA STX $EB LDA #$01 スタ$E6 スタ$E7 STA $E8 12月 $E6 BNE $FEC1 LD$E9
インド スタイル $E9 LDA $FF1F,Y BEQ $FE77 JSR $FFE9 スタ$E6 TXA
そして #$3e LDX #$04 JSR $FFD9 12月 $E7 BNE $FEDA LDY $EA インド
STY $EA LDA $FF33,Y JSR $FFE9 スタ$E7 TXA
そして #$3e LDX #$00 JSR $FFD9 12月 $E8 BNE $FEFD LDA #$09 STA $400E; LDA #$08 STA $400F; LDY$EB インド スタイル$EB LDA $FF46,Y JSR $FFE9 STA $E8
[NES] オーディオ ‐ ノイズ周波数 reg #1 [NES] オーディオ ‐ ノイズ周波数 reg #2

 Machine Translated by Google
TXA
$FEF6 そして #$3e
$FEF8 LDX #$08 $FEFA JSR $FFD9 $FEFD ジャンプ$FF6A
0357000008D408BD08B209AB097C093F 091C08FD08EE09FC09DF060C12180848 CACED413110F9010C4C8070515C4D2D4 8E0C4F00D6D6CA0B19179818CED41513 11D2CACC961857CE0F0F0FCECECECEC 0F0F0FCECECECECE0F0F0FCE
$FEF5
$FF5C $FF5E $60 FF です $FF62 $FF64 $65 FF です $FF67
$FF6A $FF6C $FF6E
$FF6F
FF70億ドル $FF7D $FF7F $FF81 $83 円 $85 FF です $87 円 $89 円 $FF8C $FF8F $FF92 $95 FF ... $FF97
LDY$E1
LDA $E3
LSR $E1
BCS FF70億ドル LSR A
BCS $FF9A JMP $FE36
LDA #$00 STA $E1 RTS
060C1247を
STA $E3
LDA #$12
STA $E4
LDA #$02
STA $E5
LDX #$9f
LDY #$7f
STX 4000ドル; STX 4004ドル; STY 4001ドル; STY 4005ドル; LDA #$20
STA $4008;
5F715F718E718EBE
[NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ スクエア2 [NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ トライアングル

 Machine Translated by Google
$FF9A $FF9C $FF9E $FFA1 $FFA3 $FFA6 $FFA9 $FFAB $FFAE $FFB1 $FFB4 $FFB7 $FFBA $FFBD $FFC0 $FFC2 $FFC4 $FFC6 $FFC8 $FFCA $FFCC $FFCE $FFD0 $FFD3 $FFD6
$FFD9 $FFDA $FFDD $FFDF $FFE2 $FFE5 $FFE8
$FFE9 $FFEA $FFEB $FFEC $FFED $FFEE $FFEF $FFF1 $FFF2
LDA $E4
LDY $E5
CMP $FF6F,Y
BNE $FFC6
LDA $FF72,Y
STA $4002;
LDX #$58
STX 4003ドル; LDA $FF75,Y
STA $4006;
STX 4007ドル; LDA $FF78,Y
STA 400Aドル; STX 4,000億ドル LDA $E5
BEQ $FFC6
12月 $E5
12月 $E4
BNE $FFD6
LDA #$00
STA $E3
LDA #$10
STA 4000ドル; STA $4004; ジャンプ$FF6A
テイ
LDA $FF01,Y
BEQ $FFE8
[NES] オーディオ ‐ スクエア 1
[NES] オーディオ ‐ スクエア 1
[NES] オーディオ ‐ スクエア2 [NES] オーディオ ‐ スクエア2
[NES] オーディオ ‐ トライアングル [NES] オーディオ ‐ トライアングル
STA $4002,X; [NES] オーディオ ‐ スクエア 1
LDA $FF00,Y
STA $4003,X; [NES] オーディオ ‐ スクエア 1 RTS
税
ROR A
TXA ロールA ロールA ロールA そして #$07 テイ
LDA $FF1A,Y
[NES] オーディオ ‐ スクエア 1 [NES] オーディオ ‐ スクエア2

 Machine Translated by Google
$FFF5
RTS
$FFF6 DW $FFFF $01FF NMI リセット IRQ
終了
